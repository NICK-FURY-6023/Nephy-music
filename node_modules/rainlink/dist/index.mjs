var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "rainlink",
      version: "1.2.2",
      description: "Another lavalink wrapper but focus on stability and rich features",
      repository: {
        type: "git",
        url: "https://github.com/RainyXeon/Rainlink.git"
      },
      scripts: {
        build: "npx tsup-node",
        prettier: "npx prettier -w ./src",
        "build:doc": "typedoc --options ./typedoc.json --sort kind",
        "build:full": "npm run prettier && npm run build:eslint && npm run build && npm run build:doc",
        "build:eslint": "npx eslint ./src --fix"
      },
      main: "dist/index.js",
      module: "dist/index.mjs",
      types: "dist/index.d.ts",
      exports: {
        ".": {
          types: "./dist/index.d.ts",
          import: "./dist/index.mjs",
          require: "./dist/index.js"
        }
      },
      keywords: [
        "bot",
        "music",
        "lavalink.js",
        "lavalink-api",
        "discord.js",
        "eris.js",
        "oceanic.js",
        "lavalink",
        "wrapper",
        "lavalink-wrapper",
        "rainlink"
      ],
      author: "RainyXeon",
      license: "GPL-3.0",
      devDependencies: {
        "@eslint/eslintrc": "^3.1.0",
        "@eslint/js": "^9.10.0",
        "@types/bun": "^1.1.9",
        "@types/node": "^22.5.4",
        "@types/node-fetch": "^2.6.11",
        "@typescript-eslint/eslint-plugin": "^8.5.0",
        "@typescript-eslint/parser": "^8.5.0",
        "discord.js": "^14.14.1",
        dokdo: "^1.0.1",
        dotenv: "^16.4.5",
        eslint: "^9.10.0",
        globals: "^15.9.0",
        prettier: "^3.2.5",
        tsup: "^8.3.0",
        typedoc: "^0.26.7",
        typescript: "^5.6.2"
      },
      tsup: {
        dts: true,
        entry: [
          "./src/index.ts"
        ],
        splitting: false,
        sourcemap: true,
        clean: true,
        format: [
          "cjs",
          "esm"
        ]
      },
      prettier: {
        trailingComma: "es5",
        tabWidth: 2,
        semi: false,
        singleQuote: true,
        printWidth: 100
      }
    };
  }
});

// src/metadata.ts
var packages = require_package();
var metadata = {
  name: "rainlink",
  version: packages ? packages : "1.0.0",
  github: "https://github.com/RainyXeon/Rainlink"
};

// src/Library/AbstractLibrary.ts
var AllowedPackets = ["VOICE_STATE_UPDATE", "VOICE_SERVER_UPDATE"];
var AbstractLibrary = class {
  constructor(client) {
    this.client = client;
    this.manager = null;
  }
  ready(nodes) {
    var _a;
    this.manager.id = this.getId();
    this.manager.shardCount = this.getShardCount();
    this.manager.emit(
      "debug",
      `[Rainlink] | Finished the initialization process | Registered ${this.manager.plugins.size} plugins | Now connect all current nodes`
    );
    for (const node of nodes) (_a = this.manager) == null ? void 0 : _a.nodes.add(node);
  }
  /** @ignore */
  set(manager) {
    this.manager = manager;
    return this;
  }
  raw(packet) {
    if (!AllowedPackets.includes(packet.t)) return;
    const guildId = packet.d.guild_id;
    const voice = this.manager.voices.get(guildId);
    if (!voice) return;
    if (packet.t === "VOICE_SERVER_UPDATE") return voice.setServerUpdate(packet.d);
    const userId = packet.d.user_id;
    if (userId !== this.manager.id) return;
    voice.setStateUpdate(packet.d);
  }
};

// src/Library/DiscordJS.ts
var DiscordJS = class extends AbstractLibrary {
  sendPacket(shardId, payload, important) {
    var _a;
    return (_a = this.client.ws.shards.get(shardId)) == null ? void 0 : _a.send(payload, important);
  }
  getId() {
    return this.client.user.id;
  }
  getShardCount() {
    return this.client.shard && this.client.shard.count ? this.client.shard.count : 1;
  }
  listen(nodes) {
    this.client.once("ready", () => this.ready(nodes));
    this.client.on("raw", (packet) => this.raw(packet));
  }
};

// src/Library/ErisJS.ts
var ErisJS = class extends AbstractLibrary {
  sendPacket(shardId, payload, important) {
    var _a;
    return (_a = this.client.shards.get(shardId)) == null ? void 0 : _a.sendWS(payload.op, payload.d, important);
  }
  getId() {
    return this.client.user.id;
  }
  getShardCount() {
    return this.client.shards && this.client.shards.size ? this.client.shards.size : 1;
  }
  listen(nodes) {
    this.client.once("ready", () => this.ready(nodes));
    this.client.on("rawWS", (packet) => this.raw(packet));
  }
};

// src/Library/OceanicJS.ts
var OceanicJS = class extends AbstractLibrary {
  sendPacket(shardId, payload, important) {
    var _a;
    return (_a = this.client.shards.get(shardId)) == null ? void 0 : _a.send(payload.op, payload.d, important);
  }
  getId() {
    return this.client.user.id;
  }
  getShardCount() {
    return this.client.shards && this.client.shards.size ? this.client.shards.size : 1;
  }
  listen(nodes) {
    this.client.once("ready", () => this.ready(nodes));
    this.client.on("packet", (packet) => this.raw(packet));
  }
};

// src/Library/Seyfert.ts
var Seyfert = class extends AbstractLibrary {
  sendPacket(shardId, payload) {
    return this.client.gateway.send(shardId, payload);
  }
  getId() {
    return this.client.botId;
  }
  getShardCount() {
    return this.client.gateway.totalShards;
  }
  listen(nodes) {
    this.client.events.values.RAW = {
      data: { name: "raw" },
      run: (packet) => {
        if (packet.t === "READY") return this.ready(nodes);
        return this.raw(packet);
      }
    };
  }
};

// src/Library/index.ts
var Library_default = {
  DiscordJS,
  ErisJS,
  OceanicJS,
  Seyfert
};

// src/Interface/Manager.ts
var RainlinkSearchResultType = /* @__PURE__ */ ((RainlinkSearchResultType2) => {
  RainlinkSearchResultType2["TRACK"] = "TRACK";
  RainlinkSearchResultType2["PLAYLIST"] = "PLAYLIST";
  RainlinkSearchResultType2["SEARCH"] = "SEARCH";
  return RainlinkSearchResultType2;
})(RainlinkSearchResultType || {});

// src/Rainlink.ts
import { EventEmitter as EventEmitter3 } from "node:events";

// src/Interface/Constants.ts
var RainlinkEvents = /* @__PURE__ */ ((RainlinkEvents2) => {
  RainlinkEvents2["Debug"] = "debug";
  RainlinkEvents2["NodeConnect"] = "nodeConnect";
  RainlinkEvents2["NodeDisconnect"] = "nodeDisconnect";
  RainlinkEvents2["NodeReconnect"] = "nodeReconnect";
  RainlinkEvents2["NodeClosed"] = "nodeClosed";
  RainlinkEvents2["NodeError"] = "nodeError";
  RainlinkEvents2["PlayerCreate"] = "playerCreate";
  RainlinkEvents2["PlayerDestroy"] = "playerDestroy";
  RainlinkEvents2["PlayerConnect"] = "playerConnect";
  RainlinkEvents2["PlayerDisconnect"] = "playerDisconnect";
  RainlinkEvents2["PlayerUpdate"] = "playerUpdate";
  RainlinkEvents2["PlayerMoved"] = "playerMoved";
  RainlinkEvents2["PlayerPause"] = "playerPause";
  RainlinkEvents2["PlayerResume"] = "playerResume";
  RainlinkEvents2["PlayerException"] = "playerException";
  RainlinkEvents2["PlayerWebsocketClosed"] = "playerWebsocketClosed";
  RainlinkEvents2["TrackStuck"] = "trackStuck";
  RainlinkEvents2["TrackStart"] = "trackStart";
  RainlinkEvents2["TrackEnd"] = "trackEnd";
  RainlinkEvents2["TrackResolveError"] = "trackResolveError";
  RainlinkEvents2["QueueAdd"] = "queueAdd";
  RainlinkEvents2["QueueRemove"] = "queueRemove";
  RainlinkEvents2["QueueShuffle"] = "queueShuffle";
  RainlinkEvents2["QueueClear"] = "queueClear";
  RainlinkEvents2["QueueEmpty"] = "queueEmpty";
  return RainlinkEvents2;
})(RainlinkEvents || {});
var RainlinkConnectState = /* @__PURE__ */ ((RainlinkConnectState2) => {
  RainlinkConnectState2[RainlinkConnectState2["Connected"] = 0] = "Connected";
  RainlinkConnectState2[RainlinkConnectState2["Disconnected"] = 1] = "Disconnected";
  RainlinkConnectState2[RainlinkConnectState2["Closed"] = 2] = "Closed";
  return RainlinkConnectState2;
})(RainlinkConnectState || {});
var VoiceState = /* @__PURE__ */ ((VoiceState2) => {
  VoiceState2[VoiceState2["SESSION_READY"] = 0] = "SESSION_READY";
  VoiceState2[VoiceState2["SESSION_ID_MISSING"] = 1] = "SESSION_ID_MISSING";
  VoiceState2[VoiceState2["SESSION_ENDPOINT_MISSING"] = 2] = "SESSION_ENDPOINT_MISSING";
  VoiceState2[VoiceState2["SESSION_FAILED_UPDATE"] = 3] = "SESSION_FAILED_UPDATE";
  return VoiceState2;
})(VoiceState || {});
var VoiceConnectState = /* @__PURE__ */ ((VoiceConnectState2) => {
  VoiceConnectState2[VoiceConnectState2["CONNECTING"] = 0] = "CONNECTING";
  VoiceConnectState2[VoiceConnectState2["NEARLY"] = 1] = "NEARLY";
  VoiceConnectState2[VoiceConnectState2["CONNECTED"] = 2] = "CONNECTED";
  VoiceConnectState2[VoiceConnectState2["RECONNECTING"] = 3] = "RECONNECTING";
  VoiceConnectState2[VoiceConnectState2["DISCONNECTING"] = 4] = "DISCONNECTING";
  VoiceConnectState2[VoiceConnectState2["DISCONNECTED"] = 5] = "DISCONNECTED";
  return VoiceConnectState2;
})(VoiceConnectState || {});
var LavalinkLoadType = /* @__PURE__ */ ((LavalinkLoadType2) => {
  LavalinkLoadType2["TRACK"] = "track";
  LavalinkLoadType2["PLAYLIST"] = "playlist";
  LavalinkLoadType2["SEARCH"] = "search";
  LavalinkLoadType2["EMPTY"] = "empty";
  LavalinkLoadType2["ERROR"] = "error";
  return LavalinkLoadType2;
})(LavalinkLoadType || {});
var SourceIDs = [
  { name: "youtube", id: "yt" },
  { name: "youtubeMusic", id: "ytm" },
  { name: "soundcloud", id: "sc" }
];
var RainlinkPluginType = /* @__PURE__ */ ((RainlinkPluginType2) => {
  RainlinkPluginType2["Default"] = "default";
  RainlinkPluginType2["SourceResolver"] = "sourceResolver";
  return RainlinkPluginType2;
})(RainlinkPluginType || {});
var RainlinkPlayerState = /* @__PURE__ */ ((RainlinkPlayerState2) => {
  RainlinkPlayerState2[RainlinkPlayerState2["CONNECTED"] = 0] = "CONNECTED";
  RainlinkPlayerState2[RainlinkPlayerState2["DISCONNECTED"] = 1] = "DISCONNECTED";
  RainlinkPlayerState2[RainlinkPlayerState2["DESTROYED"] = 2] = "DESTROYED";
  return RainlinkPlayerState2;
})(RainlinkPlayerState || {});
var RainlinkLoopMode = /* @__PURE__ */ ((RainlinkLoopMode2) => {
  RainlinkLoopMode2["SONG"] = "song";
  RainlinkLoopMode2["QUEUE"] = "queue";
  RainlinkLoopMode2["NONE"] = "none";
  return RainlinkLoopMode2;
})(RainlinkLoopMode || {});
var RainlinkFilterData = {
  clear: {},
  eightD: {
    rotation: {
      rotationHz: 0.2
    }
  },
  soft: {
    lowPass: {
      smoothing: 20
    }
  },
  speed: {
    timescale: {
      speed: 1.501,
      pitch: 1.245,
      rate: 1.921
    }
  },
  karaoke: {
    karaoke: {
      level: 1,
      monoLevel: 1,
      filterBand: 220,
      filterWidth: 100
    }
  },
  nightcore: {
    timescale: {
      speed: 1.05,
      pitch: 1.125,
      rate: 1.05
    }
  },
  pop: {
    equalizer: [
      { band: 0, gain: -0.25 },
      { band: 1, gain: 0.48 },
      { band: 2, gain: 0.59 },
      { band: 3, gain: 0.72 },
      { band: 4, gain: 0.56 },
      { band: 6, gain: -0.24 },
      { band: 8, gain: -0.16 }
    ]
  },
  vaporwave: {
    equalizer: [
      { band: 1, gain: 0.3 },
      { band: 0, gain: 0.3 }
    ],
    timescale: { pitch: 0.5 },
    tremolo: { depth: 0.3, frequency: 14 }
  },
  bass: {
    equalizer: [
      { band: 0, gain: 0.1 },
      { band: 1, gain: 0.1 },
      { band: 2, gain: 0.05 },
      { band: 3, gain: 0.05 },
      { band: 4, gain: -0.05 },
      { band: 5, gain: -0.05 },
      { band: 6, gain: 0 },
      { band: 7, gain: -0.05 },
      { band: 8, gain: -0.05 },
      { band: 9, gain: 0 },
      { band: 10, gain: 0.05 },
      { band: 11, gain: 0.05 },
      { band: 12, gain: 0.1 },
      { band: 13, gain: 0.1 }
    ]
  },
  party: {
    equalizer: [
      { band: 0, gain: -1.16 },
      { band: 1, gain: 0.28 },
      { band: 2, gain: 0.42 },
      { band: 3, gain: 0.5 },
      { band: 4, gain: 0.36 },
      { band: 5, gain: 0 },
      { band: 6, gain: -0.3 },
      { band: 7, gain: -0.21 },
      { band: 8, gain: -0.21 }
    ]
  },
  earrape: {
    equalizer: [
      { band: 0, gain: 0.25 },
      { band: 1, gain: 0.5 },
      { band: 2, gain: -0.5 },
      { band: 3, gain: -0.25 },
      { band: 4, gain: 0 },
      { band: 6, gain: -0.025 },
      { band: 7, gain: -0.0175 },
      { band: 8, gain: 0 },
      { band: 9, gain: 0 },
      { band: 10, gain: 0.0125 },
      { band: 11, gain: 0.025 },
      { band: 12, gain: 0.375 },
      { band: 13, gain: 0.125 },
      { band: 14, gain: 0.125 }
    ]
  },
  equalizer: {
    equalizer: [
      { band: 0, gain: 0.375 },
      { band: 1, gain: 0.35 },
      { band: 2, gain: 0.125 },
      { band: 5, gain: -0.125 },
      { band: 6, gain: -0.125 },
      { band: 8, gain: 0.25 },
      { band: 9, gain: 0.125 },
      { band: 10, gain: 0.15 },
      { band: 11, gain: 0.2 },
      { band: 12, gain: 0.25 },
      { band: 13, gain: 0.35 },
      { band: 14, gain: 0.4 }
    ]
  },
  electronic: {
    equalizer: [
      { band: 0, gain: 0.375 },
      { band: 1, gain: 0.35 },
      { band: 2, gain: 0.125 },
      { band: 5, gain: -0.125 },
      { band: 6, gain: -0.125 },
      { band: 8, gain: 0.25 },
      { band: 9, gain: 0.125 },
      { band: 10, gain: 0.15 },
      { band: 11, gain: 0.2 },
      { band: 12, gain: 0.25 },
      { band: 13, gain: 0.35 },
      { band: 14, gain: 0.4 }
    ]
  },
  radio: {
    equalizer: [
      { band: 0, gain: -0.25 },
      { band: 1, gain: 0.48 },
      { band: 2, gain: 0.59 },
      { band: 3, gain: 0.72 },
      { band: 4, gain: 0.56 },
      { band: 6, gain: -0.24 },
      { band: 8, gain: -0.16 }
    ]
  },
  tremolo: {
    tremolo: {
      depth: 0.3,
      frequency: 14
    }
  },
  treblebass: {
    equalizer: [
      { band: 0, gain: 0.6 },
      { band: 1, gain: 0.67 },
      { band: 2, gain: 0.67 },
      { band: 3, gain: 0 },
      { band: 4, gain: -0.5 },
      { band: 5, gain: 0.15 },
      { band: 6, gain: -0.45 },
      { band: 7, gain: 0.23 },
      { band: 8, gain: 0.35 },
      { band: 9, gain: 0.45 },
      { band: 10, gain: 0.55 },
      { band: 11, gain: 0.6 },
      { band: 12, gain: 0.55 }
    ]
  },
  vibrato: {
    vibrato: {
      depth: 0.3,
      frequency: 14
    }
  },
  china: {
    timescale: {
      speed: 0.75,
      pitch: 1.25,
      rate: 1.25
    }
  },
  chimpunk: {
    timescale: {
      speed: 1.05,
      pitch: 1.35,
      rate: 1.25
    }
  },
  darthvader: {
    timescale: {
      speed: 0.975,
      pitch: 0.5,
      rate: 0.8
    }
  },
  daycore: {
    equalizer: [
      { band: 0, gain: 0 },
      { band: 1, gain: 0 },
      { band: 2, gain: 0 },
      { band: 3, gain: 0 },
      { band: 4, gain: 0 },
      { band: 5, gain: 0 },
      { band: 6, gain: 0 },
      { band: 7, gain: 0 },
      { band: 8, gain: -0.25 },
      { band: 9, gain: -0.25 },
      { band: 10, gain: -0.25 },
      { band: 11, gain: -0.25 },
      { band: 12, gain: -0.25 },
      { band: 13, gain: -0.25 }
    ],
    timescale: {
      pitch: 0.63,
      rate: 1.05
    }
  },
  doubletime: {
    timescale: {
      speed: 1.165
    }
  },
  pitch: {
    timescale: { pitch: 3 }
  },
  rate: {
    timescale: { rate: 2 }
  },
  slow: {
    timescale: {
      speed: 0.5,
      pitch: 1,
      rate: 0.8
    }
  }
};

// src/Player/RainlinkTrack.ts
var RainlinkTrack = class {
  /**
    * The rainlink track class for playing track from lavalink
    * @param options The raw track resolved from rest, use RawTrack interface
    * @param requester The requester details of this track
    */
  constructor(options, requester, driverName) {
    this.options = options;
    /** Track's URL */
    this.uri = null;
    /** Track's artwork URL */
    this.artworkUrl = null;
    /** Track's isrc */
    this.isrc = null;
    /** Track's realUri (youtube fall back) */
    this.realUri = null;
    this.encoded = options.encoded;
    this.identifier = options.info.identifier;
    this.isSeekable = options.info.isSeekable;
    this.author = options.info.author;
    this.duration = options.info.length;
    this.isStream = options.info.isStream;
    this.position = options.info.position;
    this.title = options.info.title;
    this.uri = options.info.uri;
    this.artworkUrl = options.info.artworkUrl;
    this.isrc = options.info.isrc;
    this.source = options.info.sourceName;
    this.pluginInfo = options.pluginInfo;
    this.requester = requester;
    this.realUri = null;
    this.driverName = driverName;
  }
  /**
    * Whenever track is able to play or not
    * @returns boolean
    */
  get isPlayable() {
    return !!this.encoded && !!this.source && !!this.identifier && !!this.author && !!this.duration && !!this.title && !!this.uri;
  }
  /**
    * Get all raw details of the track
    * @returns RawTrack
    */
  get raw() {
    return {
      encoded: this.encoded,
      info: {
        identifier: this.identifier,
        isSeekable: this.isSeekable,
        author: this.author,
        length: this.duration,
        isStream: this.isStream,
        position: this.position,
        title: this.title,
        uri: this.uri,
        artworkUrl: this.artworkUrl,
        isrc: this.isrc,
        sourceName: this.source
      },
      pluginInfo: this.pluginInfo
    };
  }
  /** @ignore */
  resolver(player, options) {
    return __async(this, null, function* () {
      const { overwrite } = options ? options : { overwrite: false };
      if (this.isPlayable && this.driverName == player.node.driver.id) {
        this.realUri = this.raw.info.uri;
        return this;
      }
      player.manager.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Track] | Resolving ${this.source} track ${this.title}; Source: ${this.source}`
      );
      const result = yield this.getTrack(player);
      if (!result) throw new Error("No results found");
      this.encoded = result.encoded;
      this.realUri = result.info.uri;
      this.duration = result.info.length;
      if (overwrite) {
        this.title = result.info.title;
        this.identifier = result.info.identifier;
        this.isSeekable = result.info.isSeekable;
        this.author = result.info.author;
        this.duration = result.info.length;
        this.isStream = result.info.isStream;
        this.uri = result.info.uri;
      }
      return this;
    });
  }
  getTrack(player) {
    return __async(this, null, function* () {
      const result = yield this.resolverEngine(player);
      if (!result || !result.tracks.length) throw new Error("No results found");
      const rawTracks = result.tracks.map((x) => x.raw);
      if (this.author) {
        const author = [this.author, `${this.author} - Topic`];
        const officialTrack = rawTracks.find(
          (track) => author.some(
            (name) => new RegExp(`^${this.escapeRegExp(name)}$`, "i").test(track.info.author)
          ) || new RegExp(`^${this.escapeRegExp(this.title)}$`, "i").test(track.info.title)
        );
        if (officialTrack) return officialTrack;
      }
      if (this.duration) {
        const sameDuration = rawTracks.find(
          (track) => track.info.length >= (this.duration ? this.duration : 0) - 2e3 && track.info.length <= (this.duration ? this.duration : 0) + 2e3
        );
        if (sameDuration) return sameDuration;
      }
      return rawTracks[0];
    });
  }
  escapeRegExp(string) {
    return string.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
  }
  resolverEngine(player) {
    return __async(this, null, function* () {
      var _a;
      const defaultSearchEngine = player.manager.rainlinkOptions.options.defaultSearchEngine;
      const engine = player.manager.searchEngines.get(this.source || defaultSearchEngine || "youtube");
      const searchQuery = [this.author, this.title].filter((x) => !!x).join(" - ");
      const searchFallbackEngineName = player.manager.rainlinkOptions.options.searchFallback.engine;
      const searchFallbackEngine = player.manager.searchEngines.get(searchFallbackEngineName);
      const prase1 = yield player.search(`directSearch=${this.uri}`, {
        requester: this.requester
      });
      if (prase1.tracks.length !== 0) return prase1;
      const prase2 = yield player.search(`directSearch=${engine}search:${searchQuery}`, {
        requester: this.requester
      });
      if (prase2.tracks.length !== 0) return prase2;
      if (((_a = player.manager.rainlinkOptions.options.searchFallback) == null ? void 0 : _a.enable) && searchFallbackEngine) {
        const prase3 = yield player.search(
          `directSearch=${searchFallbackEngine}search:${searchQuery}`,
          {
            requester: this.requester
          }
        );
        if (prase3.tracks.length !== 0) return prase3;
      }
      return {
        type: "SEARCH" /* SEARCH */,
        playlistName: void 0,
        tracks: []
      };
    });
  }
};

// src/Player/RainlinkQueue.ts
var RainlinkQueue = class extends Array {
  /**
    * The rainlink track queue handler class
    * @param manager The rainlink manager
    * @param player The current rainlink player
    */
  constructor(manager, player) {
    super();
    /** Current playing track */
    this.current = null;
    /** Previous playing tracks */
    this.previous = [];
    this.manager = manager;
    this.player = player;
  }
  /** Get the size of queue */
  get size() {
    return this.length;
  }
  /** Get the size of queue including current */
  get totalSize() {
    return this.length + (this.current ? 1 : 0);
  }
  /** Check if the queue is empty or not */
  get isEmpty() {
    return this.length === 0;
  }
  /** Get the queue's duration */
  get duration() {
    return this.reduce((acc, cur) => acc + (cur.duration || 0), 0);
  }
  /**
    * Add track(s) to the queue
    * @param track RainlinkTrack to add
    * @returns RainlinkQueue
    */
  add(track) {
    if (Array.isArray(track) && track.some((t) => !(t instanceof RainlinkTrack)))
      throw new Error("Track must be an instance of RainlinkTrack");
    if (!Array.isArray(track) && !(track instanceof RainlinkTrack)) track = [track];
    if (!this.current) {
      if (Array.isArray(track)) this.current = track.shift();
      else {
        this.current = track;
        return this;
      }
    }
    if (Array.isArray(track)) for (const t of track) this.push(t);
    else this.push(track);
    this.manager.emit(
      "queueAdd" /* QueueAdd */,
      this.player,
      this,
      Array.isArray(track) ? [...track] : [track]
    );
    return this;
  }
  /**
    * Remove track from the queue
    * @param position Position of the track
    * @returns RainlinkQueue
    */
  remove(position) {
    if (position < 0 || position >= this.length)
      throw new Error("Position must be between 0 and " + (this.length - 1));
    const track = this[position];
    this.splice(position, 1);
    this.manager.emit("queueRemove" /* QueueRemove */, this.player, this, track);
    return this;
  }
  /** Shuffle the queue */
  shuffle() {
    for (let i = this.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [this[i], this[j]] = [this[j], this[i]];
    }
    this.manager.emit("queueShuffle" /* QueueShuffle */, this.player, this);
    return this;
  }
  /** Clear the queue */
  clear() {
    this.splice(0, this.length);
    this.manager.emit("queueClear" /* QueueClear */, this.player, this);
    return this;
  }
};

// src/Utilities/RainlinkDatabase.ts
var RainlinkDatabase = class {
  constructor() {
    this.cache = {};
  }
  /**
    * Get data from database
    * @param key key of that data
    * @returns D
    */
  get(key) {
    var _a;
    return (_a = this.cache[key]) != null ? _a : void 0;
  }
  /**
    * detete data from database and returns the deleted data
    * @param key key of that data
    * @returns D
    */
  delete(key) {
    var _a;
    const data = (_a = this.cache[key]) != null ? _a : void 0;
    delete this.cache[key];
    return data;
  }
  /**
    * detete all data from database
    */
  clear() {
    this.cache = {};
  }
  /**
    * Set data from database
    * @param key the key you want to set
    * @param data data of that key
    * @returns D
    */
  set(key, data) {
    this.cache[key] = data;
    return data;
  }
  /**
    * executes a provided function once for each array element.
    * @param callback Callback function
    */
  forEach(callback) {
    for (const data of this.full) {
      callback(data[1], data[0]);
    }
  }
  /**
    * Get how many elements of current database
    * @returns number
    */
  get size() {
    return Object.keys(this.cache).length;
  }
  /**
    * Get all current values of current database
    * @returns unknown[]
    */
  get values() {
    return Object.values(this.cache);
  }
  /**
    * Get all current values of current database
    * @returns unknown[]
    */
  get full() {
    const finalRes = [];
    const keys = Object.keys(this.cache);
    const values = Object.values(this.cache);
    for (let i = 0; i < keys.length; i++) {
      finalRes.push([keys[i], values[i]]);
    }
    return finalRes;
  }
};

// src/Player/RainlinkFilter.ts
import util from "node:util";
var RainlinkFilter = class {
  constructor(player) {
    this.player = player;
    /**
      * Current filter config
      */
    this.currentFilter = null;
  }
  /**
    * Set a filter that prebuilt in rainlink
    * @param filter The filter name
    * @returns RainlinkPlayer
    */
  set(filter) {
    return __async(this, null, function* () {
      this.checkDestroyed();
      const filterData = RainlinkFilterData[filter];
      if (!filterData) {
        this.debug(`Filter ${filter} not avaliable in Rainlink's filter prebuilt`);
        return this.player;
      }
      yield this.player.send({
        guildId: this.player.guildId,
        playerOptions: {
          filters: filterData
        }
      });
      this.currentFilter = filterData;
      this.debug(
        filter !== "clear" ? `${filter} filter has been successfully set.` : "All filters have been successfully reset to their default positions."
      );
      return this.player;
    });
  }
  /**
    * Clear all the filter
    * @returns RainlinkPlayer
    */
  clear() {
    return __async(this, null, function* () {
      this.checkDestroyed();
      yield this.player.send({
        guildId: this.player.guildId,
        playerOptions: {
          filters: {}
        }
      });
      this.currentFilter = null;
      this.debug("All filters have been successfully reset to their default positions.");
      return this.player;
    });
  }
  /**
    * Sets the filter volume of the player
    * @param volume Target volume 0.0-5.0
    */
  setVolume(volume) {
    return __async(this, null, function* () {
      return this.setRaw({ volume });
    });
  }
  /**
    * Change the equalizer settings applied to the currently playing track
    * @param equalizer An array of objects that conforms to the Bands type that define volumes at different frequencies
    */
  setEqualizer(equalizer) {
    return this.setRaw({ equalizer });
  }
  /**
    * Change the karaoke settings applied to the currently playing track
    * @param karaoke An object that conforms to the KaraokeSettings type that defines a range of frequencies to mute
    */
  setKaraoke(karaoke) {
    return this.setRaw({ karaoke: karaoke || null });
  }
  /**
    * Change the timescale settings applied to the currently playing track
    * @param timescale An object that conforms to the TimescaleSettings type that defines the time signature to play the audio at
    */
  setTimescale(timescale) {
    return this.setRaw({ timescale: timescale || null });
  }
  /**
    * Change the tremolo settings applied to the currently playing track
    * @param tremolo An object that conforms to the FreqSettings type that defines an oscillation in volume
    */
  setTremolo(tremolo) {
    return this.setRaw({ tremolo: tremolo || null });
  }
  /**
    * Change the vibrato settings applied to the currently playing track
    * @param vibrato An object that conforms to the FreqSettings type that defines an oscillation in pitch
    */
  setVibrato(vibrato) {
    return this.setRaw({ vibrato: vibrato || null });
  }
  /**
    * Change the rotation settings applied to the currently playing track
    * @param rotation An object that conforms to the RotationSettings type that defines the frequency of audio rotating round the listener
    */
  setRotation(rotation) {
    return this.setRaw({ rotation: rotation || null });
  }
  /**
    * Change the distortion settings applied to the currently playing track
    * @param distortion An object that conforms to DistortionSettings that defines distortions in the audio
    * @returns The current player instance
    */
  setDistortion(distortion) {
    return this.setRaw({ distortion: distortion || null });
  }
  /**
    * Change the channel mix settings applied to the currently playing track
    * @param channelMix An object that conforms to ChannelMixSettings that defines how much the left and right channels affect each other (setting all factors to 0.5 causes both channels to get the same audio)
    */
  setChannelMix(channelMix) {
    return this.setRaw({ channelMix: channelMix || null });
  }
  /**
    * Change the low pass settings applied to the currently playing track
    * @param lowPass An object that conforms to LowPassSettings that defines the amount of suppression on higher frequencies
    */
  setLowPass(lowPass) {
    return this.setRaw({ lowPass: lowPass || null });
  }
  /**
    * Set a custom filter
    * @param filter The filter name
    * @returns RainlinkPlayer
    */
  setRaw(filter) {
    return __async(this, null, function* () {
      this.checkDestroyed();
      yield this.player.send({
        guildId: this.player.guildId,
        playerOptions: {
          filters: filter
        }
      });
      this.currentFilter = filter;
      this.debug("Custom filter has been successfully set. Data: " + util.inspect(filter));
      return this.player;
    });
  }
  debug(logs) {
    this.player.manager.emit(
      "debug" /* Debug */,
      `[Rainlink] / [Player @ ${this.player.guildId}] / [Filter] | ${logs}`
    );
  }
  checkDestroyed() {
    if (this.player.state === 2 /* DESTROYED */) throw new Error("Player is destroyed");
  }
};

// src/Utilities/RainlinkFunctions.ts
var RainlinkFunctions = class _RainlinkFunctions extends RainlinkDatabase {
  /**
    * Function to execute custom function
    * @param commandName Function name
    * @param args Function args
    */
  exec(commandName, ...args) {
    return __async(this, null, function* () {
      const func = __superGet(_RainlinkFunctions.prototype, this, "get").call(this, commandName);
      if (!func) return void 0;
      const getData = yield func(...args);
      return getData;
    });
  }
};

// src/Player/RainlinkPlayer.ts
var RainlinkPlayer = class {
  /**
    * The rainlink player handler class
    * @param manager The rainlink manager
    * @param voiceOptions The rainlink voice option, use VoiceChannelOptions interface
    * @param node The rainlink current use node
    */
  constructor(manager, voice, node) {
    /**
      * Whether the player is paused or not
      */
    this.paused = true;
    /**
      * Get the current track's position of the player
      */
    this.position = 0;
    /**
      * Whether the player is playing or not
      */
    this.playing = false;
    /**
      * ID of the current track
      */
    this.track = null;
    /** @ignore */
    this.sudoDestroy = false;
    var _a, _b, _c, _d;
    this.voice = voice;
    this.manager = manager;
    const rainlinkOptions = this.manager.rainlinkOptions.options;
    this.guildId = this.voice.guildId;
    this.voiceId = this.voice.voiceId;
    this.shardId = this.voice.shardId;
    this.mute = (_a = this.voice.mute) != null ? _a : false;
    this.deaf = (_b = this.voice.deaf) != null ? _b : false;
    this.node = node;
    this.guildId = this.voice.guildId;
    this.voiceId = this.voice.voiceId;
    this.textId = this.voice.options.textId;
    const customQueue = rainlinkOptions.structures && rainlinkOptions.structures.queue;
    this.queue = customQueue ? new customQueue(this.manager, this) : new RainlinkQueue(this.manager, this);
    this.data = new RainlinkDatabase();
    if (rainlinkOptions.structures && rainlinkOptions.structures.filter)
      this.filter = new rainlinkOptions.structures.filter(this);
    else this.filter = new RainlinkFilter(this);
    this.volume = rainlinkOptions.defaultVolume;
    this.loop = "none" /* NONE */;
    this.state = 2 /* DESTROYED */;
    this.deaf = (_c = this.voice.deaf) != null ? _c : false;
    this.mute = (_d = this.voice.mute) != null ? _d : false;
    this.functions = new RainlinkFunctions();
    if (this.node.driver.playerFunctions.size !== 0) {
      this.node.driver.playerFunctions.forEach((data, key) => {
        this.functions.set(key, data.bind(null, this));
      });
    }
    if (this.voice.options.volume && this.voice.options.volume !== this.volume)
      this.volume = this.voice.options.volume;
  }
  /**
    * Sends server update to lavalink
    * @internal
    */
  sendServerUpdate() {
    return __async(this, null, function* () {
      const playerUpdate = {
        guildId: this.guildId,
        playerOptions: {
          voice: {
            token: this.voice.serverUpdate.token,
            endpoint: this.voice.serverUpdate.endpoint,
            sessionId: this.voice.sessionId
          }
        }
      };
      yield this.node.rest.updatePlayer(playerUpdate);
    });
  }
  /**
    * Destroy the player
    * @internal
    */
  destroy() {
    return __async(this, null, function* () {
      this.checkDestroyed();
      this.sudoDestroy = true;
      if (this.playing)
        yield this.node.rest.updatePlayer({
          guildId: this.guildId,
          playerOptions: {
            track: {
              encoded: null,
              length: 0
            }
          }
        });
      this.clear(false);
      this.disconnect();
      yield this.node.rest.destroyPlayer(this.guildId);
      this.manager.players.delete(this.guildId);
      this.state = 2 /* DESTROYED */;
      this.debug("Player destroyed");
      this.voiceId = "";
      this.manager.emit("playerDestroy" /* PlayerDestroy */, this);
      this.sudoDestroy = false;
    });
  }
  /**
    * Play a track
    * @param track Track to play
    * @param options Play options
    * @returns RainlinkPlayer
    */
  play(track, options) {
    return __async(this, null, function* () {
      var _a;
      this.checkDestroyed();
      if (track && !(track instanceof RainlinkTrack)) throw new Error("track must be a RainlinkTrack");
      if (!track && !this.queue.totalSize) throw new Error("No track is available to play");
      if (!options || typeof options.replaceCurrent !== "boolean")
        options = __spreadProps(__spreadValues({}, options), { replaceCurrent: false });
      if (track) {
        if (!options.replaceCurrent && this.queue.current) this.queue.unshift(this.queue.current);
        this.queue.current = track;
      } else if (!this.queue.current) this.queue.current = this.queue.shift();
      if (!this.queue.current) throw new Error("No track is available to play");
      const current = this.queue.current;
      let errorMessage;
      const resolveResult = yield current.resolver(this).catch((e) => {
        errorMessage = e.message;
        return null;
      });
      if (!resolveResult || resolveResult && !resolveResult.isPlayable) {
        this.manager.emit("trackResolveError" /* TrackResolveError */, this, current, errorMessage);
        this.debug(`Player resolve error: ${errorMessage}`);
        this.queue.current = null;
        this.queue.size ? yield this.play() : this.manager.emit("queueEmpty" /* QueueEmpty */, this, this.queue);
        return this;
      }
      this.playing = true;
      this.track = current.encoded;
      const playerOptions = __spreadProps(__spreadValues({
        track: {
          encoded: current.encoded,
          length: current.duration
        }
      }, options), {
        volume: this.volume
      });
      if (playerOptions.paused) {
        this.paused = playerOptions.paused;
        this.playing = !this.paused;
      }
      if (playerOptions.position) this.position = playerOptions.position;
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        noReplace: (_a = options == null ? void 0 : options.noReplace) != null ? _a : false,
        playerOptions
      });
      return this;
    });
  }
  /**
    * Set the loop mode of the track
    * @param mode Mode to loop
    * @returns RainlinkPlayer
    */
  setLoop(mode) {
    this.checkDestroyed();
    this.loop = mode;
    return this;
  }
  /**
    * Search track directly from player
    * @param query The track search query link
    * @param options The track search options
    * @returns RainlinkSearchResult
    */
  search(query, options) {
    return __async(this, null, function* () {
      this.checkDestroyed();
      return yield this.manager.search(query, __spreadValues({
        nodeName: this.node.options.name
      }, options));
    });
  }
  /**
    * Pause the track
    * @returns RainlinkPlayer
    */
  pause() {
    return __async(this, null, function* () {
      this.checkDestroyed();
      if (this.paused == true) return this;
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        playerOptions: {
          paused: true
        }
      });
      this.paused = true;
      this.playing = false;
      this.manager.emit("playerPause" /* PlayerPause */, this, this.queue.current);
      return this;
    });
  }
  /**
    * Resume the track
    * @returns RainlinkPlayer
    */
  resume() {
    return __async(this, null, function* () {
      this.checkDestroyed();
      if (this.paused == false) return this;
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        playerOptions: {
          paused: false
        }
      });
      this.paused = false;
      this.playing = true;
      this.manager.emit("playerResume" /* PlayerResume */, this, this.queue.current);
      return this;
    });
  }
  /**
    * Pause or resume a track but different method
    * @param mode Whether to pause or not
    * @returns RainlinkPlayer
    */
  setPause(mode) {
    return __async(this, null, function* () {
      this.checkDestroyed();
      if (this.paused == mode) return this;
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        playerOptions: {
          paused: mode
        }
      });
      this.paused = mode;
      this.playing = !mode;
      this.manager.emit(
        mode ? "playerPause" /* PlayerPause */ : "playerResume" /* PlayerResume */,
        this,
        this.queue.current
      );
      return this;
    });
  }
  /**
    * Play the previous track
    * @returns RainlinkPlayer
    */
  previous() {
    return __async(this, null, function* () {
      this.checkDestroyed();
      const prevoiusData = this.queue.previous;
      const current = this.queue.current;
      const index = prevoiusData.length - 1;
      if (index === -1 || !current) return this;
      yield this.play(prevoiusData[index]);
      this.queue.previous.splice(index, 1);
      return this;
    });
  }
  /**
    * Get all previous track
    * @returns RainlinkTrack[]
    */
  getPrevious() {
    this.checkDestroyed();
    return this.queue.previous;
  }
  /**
    * Skip the current track
    * @returns RainlinkPlayer
    */
  skip() {
    return __async(this, null, function* () {
      this.checkDestroyed();
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        playerOptions: {
          track: {
            encoded: null
          }
        }
      });
      return this;
    });
  }
  /**
    * Seek to another position in track
    * @param position Position to seek
    * @returns RainlinkPlayer
    */
  seek(position) {
    return __async(this, null, function* () {
      var _a, _b;
      this.checkDestroyed();
      if (!this.queue.current) throw new Error("Player has no current track in it's queue");
      if (!this.queue.current.isSeekable) throw new Error("The current track isn't seekable");
      position = Number(position);
      if (isNaN(position)) throw new Error("position must be a number");
      if (position < 0 || position > ((_a = this.queue.current.duration) != null ? _a : 0))
        position = Math.max(Math.min(position, (_b = this.queue.current.duration) != null ? _b : 0), 0);
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        playerOptions: {
          position
        }
      });
      this.queue.current.position = position;
      return this;
    });
  }
  /**
    * Set another volume in player
    * @param volume Volume to cange
    * @returns RainlinkPlayer
    */
  setVolume(volume) {
    return __async(this, null, function* () {
      this.checkDestroyed();
      if (isNaN(volume)) throw new Error("volume must be a number");
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        playerOptions: {
          volume
        }
      });
      this.volume = volume;
      return this;
    });
  }
  /**
    * Set player to mute or unmute
    * @param enable Enable or not
    * @returns RainlinkPlayer
    */
  setMute(enable) {
    this.checkDestroyed();
    if (enable == this.mute) return this;
    this.mute = enable;
    this.voice.mute = this.mute;
    this.voice.sendVoiceUpdate();
    return this;
  }
  /**
    * Stop all avtivities and reset to default
    * @param destroy Whenever you want to destroy a player or not
    * @returns RainlinkPlayer
    */
  stop(destroy) {
    return __async(this, null, function* () {
      this.checkDestroyed();
      if (destroy) {
        yield this.destroy();
        return this;
      }
      this.clear(false);
      yield this.node.rest.updatePlayer({
        guildId: this.guildId,
        playerOptions: {
          track: {
            encoded: null
          }
        }
      });
      this.manager.emit("trackEnd" /* TrackEnd */, this, this.queue.current);
      return this;
    });
  }
  /**
    * Reset all data to default
    * @param emitEmpty Whenever emit empty event or not
    */
  clear(emitEmpty) {
    var _a;
    this.loop = "none" /* NONE */;
    this.queue.clear();
    this.queue.current = void 0;
    this.queue.previous.length = 0;
    this.volume = (_a = this.manager.rainlinkOptions.options.defaultVolume) != null ? _a : 100;
    this.paused = true;
    this.playing = false;
    this.track = null;
    this.data.clear();
    this.position = 0;
    if (emitEmpty) this.manager.emit("queueEmpty" /* QueueEmpty */, this, this.queue);
    return;
  }
  /**
    * Set player to deaf or undeaf
    * @param enable Enable or not
    * @returns RainlinkPlayer
    */
  setDeaf(enable) {
    this.checkDestroyed();
    if (enable == this.deaf) return this;
    this.deaf = enable;
    this.voice.deaf = this.deaf;
    this.voice.sendVoiceUpdate();
    return this;
  }
  /**
    * Disconnect from the voice channel
    * @returns RainlinkPlayer
    */
  disconnect() {
    this.checkDestroyed();
    if (this.voice.state === 5 /* DISCONNECTED */) return this;
    this.voiceId = null;
    this.deaf = false;
    this.mute = false;
    this.voice.disconnect();
    this.pause();
    this.state = 1 /* DISCONNECTED */;
    this.debug("Player disconnected");
    return this;
  }
  /**
    * Set text channel
    * @param textId Text channel ID
    * @returns RainlinkPlayer
    */
  setTextChannel(textId) {
    this.checkDestroyed();
    this.textId = textId;
    return this;
  }
  /**
    * Set voice channel and move the player to the voice channel
    * @param voiceId Voice channel ID
    * @returns RainlinkPlayer
    */
  setVoiceChannel(voiceId) {
    this.checkDestroyed();
    this.disconnect();
    this.voiceId = voiceId;
    this.voice.voiceId = voiceId;
    this.voice.connect();
    this.debugDiscord(`Player moved to voice channel ${voiceId}`);
    return this;
  }
  /**
    * Send custom player update data to lavalink server
    * @param data Data to change
    * @returns RainlinkPlayer
    */
  send(data) {
    return __async(this, null, function* () {
      this.checkDestroyed();
      yield this.node.rest.updatePlayer(data);
      return this;
    });
  }
  debug(logs) {
    this.manager.emit("debug" /* Debug */, `[Rainlink] / [Player @ ${this.guildId}] | ${logs}`);
  }
  checkDestroyed() {
    if (this.state === 2 /* DESTROYED */) throw new Error("Player is destroyed");
  }
  debugDiscord(logs) {
    this.manager.emit(
      "debug" /* Debug */,
      `[Rainlink] / [Player @ ${this.guildId}] / [Voice] | ${logs}`
    );
  }
};

// src/Player/RainlinkVoice.ts
import { EventEmitter } from "node:events";
var RainlinkVoice = class _RainlinkVoice extends EventEmitter {
  /**
    * Rainlink voice handler class
    * @param manager Rainlink manager
    * @param voiceOptions
    */
  constructor(manager, voiceOptions) {
    var _a, _b;
    super();
    /**
      * Player's voice id
      */
    this.voiceId = null;
    /**
      * Connection state
      */
    this.state = 5 /* DISCONNECTED */;
    /**
      * ID of the last voiceId connected to
      */
    this.lastvoiceId = null;
    /**
      * Region of connected voice channel
      */
    this.region = null;
    /**
      * Last region of the connected voice channel
      */
    this.lastRegion = null;
    /**
      * Cached serverUpdate event from Lavalink
      */
    this.serverUpdate = null;
    /**
      * ID of current session
      */
    this.sessionId = null;
    this.options = voiceOptions;
    this.manager = manager;
    this.guildId = this.options.guildId;
    this.voiceId = this.options.voiceId;
    this.deaf = (_a = this.options.deaf) != null ? _a : false;
    this.mute = (_b = this.options.mute) != null ? _b : false;
    this.shardId = this.options.shardId;
  }
  /**
    * Connect from the voice channel
    * @returns RainlinkPlayer
    */
  connect() {
    return __async(this, null, function* () {
      if (this.state === 0 /* CONNECTING */ || this.state === 2 /* CONNECTED */)
        return this;
      this.state = 0 /* CONNECTING */;
      this.sendVoiceUpdate();
      this.debugDiscord("Requesting Connection");
      const controller = new AbortController();
      const timeout = setTimeout(
        () => controller.abort(),
        this.manager.rainlinkOptions.options.voiceConnectionTimeout
      );
      try {
        const [status] = yield _RainlinkVoice.once(this, "connectionUpdate", {
          signal: controller.signal
        });
        if (status !== 0 /* SESSION_READY */) {
          switch (status) {
            case 1 /* SESSION_ID_MISSING */:
              throw new Error("The voice connection is not established due to missing session id");
            case 2 /* SESSION_ENDPOINT_MISSING */:
              throw new Error(
                "The voice connection is not established due to missing connection endpoint"
              );
          }
        }
        this.state = 2 /* CONNECTED */;
      } catch (error) {
        this.debugDiscord("Request Connection Failed");
        if (error.name === "AbortError")
          throw new Error(
            `The voice connection is not established in ${this.manager.rainlinkOptions.options.voiceConnectionTimeout}ms`
          );
        throw error;
      } finally {
        clearTimeout(timeout);
      }
      return this;
    });
  }
  /**
    * Send voice data to discord
    * @internal
    */
  sendVoiceUpdate() {
    this.sendDiscord({
      guild_id: this.guildId,
      channel_id: this.voiceId,
      self_deaf: this.deaf,
      self_mute: this.mute
    });
  }
  /**
    * Send data to Discord
    * @param data The data to send
    * @internal
    */
  sendDiscord(data) {
    this.manager.library.sendPacket(this.shardId, { op: 4, d: data }, false);
  }
  /**
    * Sets the server update data for this connection
    * @internal
    */
  setServerUpdate(data) {
    var _a, _b;
    if (!data.endpoint) {
      this.emit("connectionUpdate", 2 /* SESSION_ENDPOINT_MISSING */);
      return;
    }
    if (!this.sessionId) {
      this.emit("connectionUpdate", 1 /* SESSION_ID_MISSING */);
      return;
    }
    this.lastRegion = ((_a = this.region) == null ? void 0 : _a.repeat(1)) || null;
    this.region = ((_b = data.endpoint.split(".").shift()) == null ? void 0 : _b.replace(/[0-9]/g, "")) || null;
    if (this.region && this.lastRegion !== this.region) {
      this.debugDiscord(
        `Voice Region Moved | Old Region: ${this.lastRegion} New Region: ${this.region}`
      );
    }
    this.serverUpdate = data;
    this.emit("connectionUpdate", 0 /* SESSION_READY */);
    this.debugDiscord(`Server Update Received | Server: ${this.region}`);
  }
  /**
    * Update Session ID, Channel ID, Deafen status and Mute status of this instance
    * @internal
    */
  setStateUpdate({
    session_id,
    channel_id,
    self_deaf,
    self_mute
  }) {
    var _a;
    this.lastvoiceId = ((_a = this.voiceId) == null ? void 0 : _a.repeat(1)) || null;
    this.voiceId = channel_id || null;
    if (this.voiceId && this.lastvoiceId !== this.voiceId) {
      this.debugDiscord(`Channel Moved | Old Channel: ${this.voiceId}`);
    }
    if (!this.voiceId) {
      this.state = 5 /* DISCONNECTED */;
      this.debugDiscord("Channel Disconnected");
    }
    this.deaf = self_deaf;
    this.mute = self_mute;
    this.sessionId = session_id || null;
    this.debugDiscord(`State Update Received | Channel: ${this.voiceId} Session ID: ${session_id}`);
  }
  /**
    * Disconnect from the voice channel
    * @returns RainlinkPlayer
    */
  disconnect() {
    this.voiceId = null;
    this.deaf = false;
    this.mute = false;
    this.removeAllListeners();
    this.sendVoiceUpdate();
    this.state = 5 /* DISCONNECTED */;
    this.debugDiscord("Voice disconnected");
  }
  debugDiscord(logs) {
    this.manager.emit(
      "debug" /* Debug */,
      `[Rainlink] / [Player @ ${this.guildId}] / [Voice] | ${logs}`
    );
  }
};

// src/Manager/RainlinkPlayerManager.ts
var RainlinkPlayerManager = class extends RainlinkDatabase {
  /**
    * The main class for handling lavalink players
    * @param manager The rainlink manager
    */
  constructor(manager) {
    super();
    this.manager = manager;
  }
  /**
    * Create a player
    * @returns RainlinkPlayer
    * @internal
    */
  create(options) {
    return __async(this, null, function* () {
      const createdPlayer = this.get(options.guildId);
      if (createdPlayer) return createdPlayer;
      const getCurrVoice = this.manager.voices.get(options.guildId);
      if (getCurrVoice) {
        getCurrVoice.disconnect();
        this.manager.voices.delete(options.guildId);
      }
      const voiceHandler = new RainlinkVoice(this.manager, options);
      this.manager.voices.set(options.guildId, voiceHandler);
      try {
        yield voiceHandler.connect();
      } catch (err) {
        throw err;
      }
      let getCustomNode = this.manager.nodes.get(String(options.nodeName ? options.nodeName : ""));
      const reigonedNode = this.manager.nodes.full.filter(([, node2]) => node2.options.region).map(([, node2]) => node2);
      if (!getCustomNode && voiceHandler.region && reigonedNode.length !== 0) {
        const node2 = reigonedNode.filter((node3) => node3.options.region == voiceHandler.region);
        if (node2) getCustomNode = yield this.manager.nodes.getLeastUsed(node2);
      }
      const node = getCustomNode ? getCustomNode : yield this.manager.nodes.getLeastUsed();
      if (!node) throw new Error("Can't find any nodes to connect on");
      const customPlayer = this.manager.rainlinkOptions.options.structures && this.manager.rainlinkOptions.options.structures.player;
      const player = customPlayer ? new customPlayer(this.manager, voiceHandler, node) : new RainlinkPlayer(this.manager, voiceHandler, node);
      this.set(player.guildId, player);
      const onUpdate = (state) => {
        if (state !== 0 /* SESSION_READY */) return;
        player.sendServerUpdate();
      };
      yield player.sendServerUpdate();
      voiceHandler.on("connectionUpdate", onUpdate);
      player.state = 0 /* CONNECTED */;
      this.debug("Player created at " + options.guildId);
      this.manager.emit("playerCreate" /* PlayerCreate */, player);
      return player;
    });
  }
  /**
    * Destroy a player
    * @returns The destroyed / disconnected player or undefined if none
    * @internal
    */
  destroy(guildId = "") {
    return __async(this, null, function* () {
      const player = this.get(guildId);
      if (player) yield player.destroy();
    });
  }
  debug(logs) {
    this.manager.emit("debug" /* Debug */, `[Rainlink] / [PlayerManager] | ${logs}`);
  }
};

// src/Node/RainlinkRest.ts
var RainlinkRest = class {
  /**
    * The lavalink rest server handler class
    * @param manager The rainlink manager
    * @param options The rainlink node options, from RainlinkNodeOptions interface
    * @param nodeManager The rainlink's lavalink server handler class
    */
  constructor(manager, options, nodeManager) {
    this.manager = manager;
    this.options = options;
    this.nodeManager = nodeManager;
    this.sessionId = this.nodeManager.driver.sessionId ? this.nodeManager.driver.sessionId : "";
  }
  /**
    * Gets all the player with the specified sessionId
    * @returns Promise that resolves to an array of Lavalink players
    */
  getPlayers() {
    return __async(this, null, function* () {
      var _a;
      const options = {
        path: `/sessions/${this.sessionId}/players`,
        headers: { "content-type": "application/json" }
      };
      return (_a = yield this.nodeManager.driver.requester(options)) != null ? _a : [];
    });
  }
  /**
    * Gets current lavalink status
    * @returns Promise that resolves to an object of current lavalink status
    */
  getStatus() {
    return __async(this, null, function* () {
      const options = {
        path: "/stats",
        headers: { "content-type": "application/json" }
      };
      return yield this.nodeManager.driver.requester(options);
    });
  }
  /**
    * Decode a single track from "encoded" properties
    * @returns Promise that resolves to an object of raw track
    */
  decodeTrack(base64track) {
    return __async(this, null, function* () {
      const options = {
        path: "/decodetrack",
        params: {
          encodedTrack: base64track
        },
        headers: { "content-type": "application/json" }
      };
      return yield this.nodeManager.driver.requester(options);
    });
  }
  /**
    * Updates a Lavalink player
    * @returns Promise that resolves to a Lavalink player
    */
  updatePlayer(data) {
    return __async(this, null, function* () {
      var _a;
      const options = {
        path: `/sessions/${this.sessionId}/players/${data.guildId}`,
        params: { noReplace: ((_a = data.noReplace) == null ? void 0 : _a.toString()) || "false" },
        headers: { "content-type": "application/json" },
        method: "PATCH",
        data: data.playerOptions,
        rawReqData: data
      };
      yield this.nodeManager.driver.requester(options);
    });
  }
  /**
    * Destroy a Lavalink player
    * @returns Promise that resolves to a Lavalink player
    */
  destroyPlayer(guildId) {
    return __async(this, null, function* () {
      const options = {
        path: `/sessions/${this.sessionId}/players/${guildId}`,
        headers: { "content-type": "application/json" },
        method: "DELETE"
      };
      yield this.nodeManager.driver.requester(options);
    });
  }
  /**
    * A track resolver function to get track from lavalink
    * @returns LavalinkResponse
    */
  resolver(data) {
    return __async(this, null, function* () {
      const options = {
        path: "/loadtracks",
        params: { identifier: data },
        headers: { "content-type": "application/json" },
        method: "GET"
      };
      const resData = yield this.nodeManager.driver.requester(options);
      if (!resData) {
        return {
          loadType: "empty" /* EMPTY */,
          data: {}
        };
      } else return resData;
    });
  }
  /**
    * Get routeplanner status from Lavalink
    * @returns Promise that resolves to a routeplanner response
    */
  getRoutePlannerStatus() {
    return __async(this, null, function* () {
      const options = {
        path: "/routeplanner/status",
        headers: { "content-type": "application/json" }
      };
      return yield this.nodeManager.driver.requester(options);
    });
  }
  /**
    * Release blacklisted IP address into pool of IPs
    * @param address IP address
    */
  unmarkFailedAddress(address) {
    return __async(this, null, function* () {
      const options = {
        path: "/routeplanner/free/address",
        method: "POST",
        headers: { "content-type": "application/json" },
        data: { address }
      };
      yield this.nodeManager.driver.requester(options);
    });
  }
  /**
    * Get Lavalink info
    */
  getInfo() {
    return __async(this, null, function* () {
      const options = {
        path: "/info",
        headers: { "content-type": "application/json" }
      };
      return yield this.nodeManager.driver.requester(options);
    });
  }
  testJSON(text) {
    if (typeof text !== "string") {
      return false;
    }
    try {
      JSON.parse(text);
      return true;
    } catch (e) {
      return false;
    }
  }
};

// src/Node/RainlinkNode.ts
import { setTimeout as setTimeout2 } from "node:timers/promises";

// src/Node/RainlinkPlayerEvents.ts
var RainlinkPlayerEvents = class {
  constructor() {
    this.methods = {
      TrackStartEvent: this.TrackStartEvent,
      TrackEndEvent: this.TrackEndEvent,
      TrackExceptionEvent: this.TrackExceptionEvent,
      TrackStuckEvent: this.TrackStuckEvent,
      WebSocketClosedEvent: this.WebSocketClosedEvent
    };
  }
  initial(data, manager) {
    if (data.op == "playerUpdate" /* PlayerUpdate */) return this.PlayerUpdate(manager, data);
    const _function = this.methods[data.type];
    if (_function !== void 0) _function(manager, data);
  }
  TrackStartEvent(manager, data) {
    const player = manager.players.get(data.guildId);
    if (player) {
      player.playing = true;
      player.paused = false;
      manager.emit("trackStart" /* TrackStart */, player, player.queue.current);
      manager.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Player @ ${data.guildId}] / [Events] / [Start] | ` + JSON.stringify(data)
      );
    }
    return;
  }
  TrackEndEvent(manager, data) {
    const player = manager.players.get(data.guildId);
    if (player) {
      if (player.state === 2 /* DESTROYED */)
        return manager.emit(
          "debug" /* Debug */,
          `[Rainlink] / [Player @ ${data.guildId}] / [Events] / [End] | Player ${player.guildId} destroyed from end event`
        );
      manager.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Player @ ${data.guildId}] / [Events] / [End] | Tracks: ${player.queue.length} ` + JSON.stringify(data)
      );
      player.playing = false;
      player.paused = true;
      if (data.reason === "replaced") {
        return manager.emit("trackEnd" /* TrackEnd */, player, player.queue.current);
      }
      if (["loadFailed", "cleanup"].includes(data.reason)) {
        if (player.queue.current) player.queue.previous.push(player.queue.current);
        if (!player.queue.length && !player.sudoDestroy)
          return manager.emit("queueEmpty" /* QueueEmpty */, player, player.queue);
        manager.emit("queueEmpty" /* QueueEmpty */, player, player.queue);
        player.queue.current = null;
        return player.play();
      }
      if (player.loop == "song" /* SONG */ && player.queue.current)
        player.queue.unshift(player.queue.current);
      if (player.loop == "queue" /* QUEUE */ && player.queue.current)
        player.queue.push(player.queue.current);
      if (player.queue.current) player.queue.previous.push(player.queue.current);
      const currentSong = player.queue.current;
      player.queue.current = null;
      if (player.queue.length) {
        manager.emit("trackEnd" /* TrackEnd */, player, currentSong);
      } else if (!player.queue.length && !player.sudoDestroy) {
        return manager.emit("queueEmpty" /* QueueEmpty */, player, player.queue);
      } else return;
      return player.play();
    }
    return;
  }
  TrackExceptionEvent(manager, data) {
    const player = manager.players.get(data.guildId);
    if (player) {
      player.playing = false;
      player.paused = true;
      manager.emit("playerException" /* PlayerException */, player, data);
      manager.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Player @ ${data.guildId}] / [Events] / [Exception] | ` + JSON.stringify(data)
      );
    }
    return;
  }
  TrackStuckEvent(manager, data) {
    const player = manager.players.get(data.guildId);
    if (player) {
      player.playing = false;
      player.paused = true;
      manager.emit("trackStuck" /* TrackStuck */, player, data);
      manager.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Player @ ${data.guildId}] / [Events] / [Stuck] | ` + JSON.stringify(data)
      );
    }
    return;
  }
  WebSocketClosedEvent(manager, data) {
    const player = manager.players.get(data.guildId);
    if (player) {
      player.playing = false;
      player.paused = true;
      manager.emit("playerWebsocketClosed" /* PlayerWebsocketClosed */, player, data);
      manager.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Player @ ${data.guildId}] / [Events] / [WebsocketClosed] | ` + JSON.stringify(data)
      );
    }
    return;
  }
  PlayerUpdate(manager, data) {
    const player = manager.players.get(data.guildId);
    if (player) {
      player.position = Number(data.state.position);
      manager.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Player @ ${data.guildId}] / [Events] / [Updated] | ` + JSON.stringify(data)
      );
      manager.emit("playerUpdate" /* PlayerUpdate */, player, data);
    }
    return;
  }
};

// src/Drivers/AbstractDriver.ts
var AbstractDriver = class {
};

// src/Drivers/Lavalink4.ts
import util2 from "node:util";

// src/Utilities/RainlinkWebsocket.ts
import https from "node:https";
import http from "node:http";
import crypto from "node:crypto";
import EventEmitter2 from "node:events";
import { URL as URL2 } from "node:url";
import Websocket from "ws";
var RainlinkWebsocketState = /* @__PURE__ */ ((RainlinkWebsocketState2) => {
  RainlinkWebsocketState2["WAITING"] = "WAITING";
  RainlinkWebsocketState2["PROCESSING"] = "PROCESSING";
  return RainlinkWebsocketState2;
})(RainlinkWebsocketState || {});
var RainlinkWebsocket = class extends EventEmitter2 {
  /**
    * @param url The WS url have to connect
    * @param options Some additional options of PWSL
    */
  constructor(url, options) {
    super();
    this.url = url;
    this.options = options;
    this.legacyWs = void 0;
    this.socket = null;
    this.continueInfo = {
      type: -1,
      buffer: []
    };
    this.state = "WAITING" /* WAITING */;
    this.connect();
    return this;
  }
  /**
    * Connect to current websocket link
    */
  connect() {
    var _a, _b, _c;
    if (this.options.legacy || process.isBun) {
      this.bun();
      return;
    }
    const parsedUrl = new URL2(this.url);
    const isSecure = parsedUrl.protocol === "wss:";
    const agent = isSecure ? https : http;
    const key = crypto.randomBytes(16).toString("base64");
    const request = agent.request(
      (isSecure ? "https://" : "http://") + parsedUrl.hostname + parsedUrl.pathname + parsedUrl.search,
      {
        port: parsedUrl.port || (isSecure ? 443 : 80),
        timeout: (_b = (_a = this.options) == null ? void 0 : _a.timeout) != null ? _b : 0,
        headers: __spreadValues({
          "Sec-WebSocket-Key": key,
          "Sec-WebSocket-Version": 13,
          Upgrade: "websocket",
          Connection: "Upgrade"
        }, ((_c = this.options) == null ? void 0 : _c.headers) || {}),
        method: "GET"
      }
    );
    request.on("error", (err) => {
      this.emit("error", err);
      this.emit("close", 1011, "Internal Error");
      this.cleanup();
    });
    request.on("upgrade", (res, socket, head) => {
      var _a2;
      socket.setNoDelay();
      socket.setKeepAlive(true);
      if (head.length !== 0) socket.unshift(head);
      if (((_a2 = res.headers.upgrade) == null ? void 0 : _a2.toLowerCase()) !== "websocket") {
        socket.destroy();
        return;
      }
      const digest = crypto.createHash("sha1").update(key + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11").digest("base64");
      if (res.headers["sec-websocket-accept"] !== digest) {
        socket.destroy();
        return;
      }
      socket.once("readable", () => this.checkData());
      socket.on("close", () => {
        this.emit("close", 1006, "Socket close suddenly");
        this.cleanup();
      });
      socket.on("error", (err) => {
        this.emit("error", err);
        this.emit("close", 1006, "Socket error");
        this.cleanup();
      });
      this.socket = socket;
      this.emit("open");
    });
    request.end();
  }
  /**
    * Clean up all current websocket state
    * @returns boolean
    */
  cleanup() {
    if (this.legacyWs) return "legacy-is-running";
    if (this.socket) {
      this.socket.destroy();
      this.socket = null;
    }
    this.continueInfo = {
      type: -1,
      buffer: []
    };
    return true;
  }
  /**
    * Send raw buffer data to ws server
    * @returns boolean
    */
  sendData(data, options) {
    var _a;
    let payloadStartIndex = 2;
    let payloadLength = options.len;
    let mask = null;
    if (options.mask) {
      mask = Buffer.allocUnsafe(4);
      while ((mask[0] | mask[1] | mask[2] | mask[3]) === 0) crypto.randomFillSync(mask, 0, 4);
      payloadStartIndex += 4;
    }
    if (options.len >= 65536) {
      payloadStartIndex += 8;
      payloadLength = 127;
    } else if (options.len > 125) {
      payloadStartIndex += 2;
      payloadLength = 126;
    }
    const header = Buffer.allocUnsafe(payloadStartIndex);
    header[0] = options.fin ? options.opcode | 128 : options.opcode;
    header[1] = payloadLength;
    if (payloadLength === 126) {
      header.writeUInt16BE(options.len, 2);
    } else if (payloadLength === 127) {
      header.writeUIntBE(options.len, 2, 6);
    }
    if (options.mask) {
      header[1] |= 128;
      header[payloadStartIndex - 4] = mask[0];
      header[payloadStartIndex - 3] = mask[1];
      header[payloadStartIndex - 2] = mask[2];
      header[payloadStartIndex - 1] = mask[3];
      for (let i = 0; i < options.len; i++) {
        data[i] = data[i] ^ mask[i & 3];
      }
    }
    (_a = this.socket) == null ? void 0 : _a.write(Buffer.concat([header, data]));
    return true;
  }
  /**
    * Send string data to ws server
    * @returns boolean
    */
  send(data) {
    if (this.legacyWs) {
      this.legacyWs.send(data);
      return true;
    }
    const payload = Buffer.from(data, "utf-8");
    return this.sendData(payload, { len: payload.length, fin: true, opcode: 1, mask: true });
  }
  /**
    * Close the connection of tthe current ws server
    * @returns boolean
    */
  close(code, reason) {
    if (this.legacyWs) this.legacyWs.close(1e3, "Self closed");
    const data = Buffer.allocUnsafe(2 + Buffer.byteLength(reason != null ? reason : "normal close"));
    data.writeUInt16BE(code != null ? code : 1e3);
    data.write(reason != null ? reason : "normal close", 2);
    this.sendData(data, { len: data.length, fin: true, opcode: 8 });
    return true;
  }
  /** @ignore */
  on(event, listener) {
    super.on(event, (...args) => listener(...args));
    return this;
  }
  /** @ignore */
  once(event, listener) {
    super.once(event, (...args) => listener(...args));
    return this;
  }
  /** @ignore */
  off(event, listener) {
    super.off(event, (...args) => listener(...args));
    return this;
  }
  /** @ignore */
  emit(event, ...data) {
    return super.emit(event, ...data);
  }
  bun() {
    return __async(this, null, function* () {
      this.legacyWs = new Websocket(this.url, {
        headers: this.options.headers
      });
      this.legacyWs.on("close", (code, reason) => {
        var _a;
        this.emit("close", code, reason);
        (_a = this.legacyWs) == null ? void 0 : _a.removeAllListeners();
      });
      this.legacyWs.on("message", (data, isBin) => this.emit("message", data.toString(), isBin));
      this.legacyWs.on("open", () => this.emit("open"));
      this.legacyWs.on("error", (err) => this.emit("error", err));
      this.legacyWs.on("pong", () => this.emit("pong"));
      this.legacyWs.on(
        "unexpected-response",
        (req, res) => this.emit("error", new Error("Unexpected Response! " + res.statusCode))
      );
    });
  }
  checkData() {
    return __async(this, null, function* () {
      var _a, _b;
      const data = (_a = this.socket) == null ? void 0 : _a.read();
      if (data && this.state === "WAITING") {
        this.state = "PROCESSING" /* PROCESSING */;
        yield this.processData(data);
        this.state = "WAITING" /* WAITING */;
      }
      (_b = this.socket) == null ? void 0 : _b.once("readable", () => this.checkData());
    });
  }
  parseFrameHeaderInfo(buffer) {
    let startIndex = 2;
    const opcode = buffer[0] & 15;
    const fin = (buffer[0] & 128) === 128;
    let payloadLength = buffer[1] & 127;
    let mask = null;
    if ((buffer[1] & 128) === 128) {
      mask = buffer.subarray(startIndex, startIndex + 4);
      startIndex += 4;
    }
    if (payloadLength === 126) {
      startIndex += 2;
      payloadLength = buffer.readUInt16BE(2);
    } else if (payloadLength === 127) {
      startIndex += 8;
      payloadLength = buffer.readUIntBE(4, 8);
    }
    return {
      opcode,
      fin,
      payloadLength,
      mask,
      startIndex
    };
  }
  parseFrameHeader(info, buffer) {
    const slicedBuffer = buffer.subarray(info.startIndex, info.startIndex + info.payloadLength);
    if (info.mask) {
      for (let i = 0; i < info.payloadLength; i++) {
        slicedBuffer[i] = slicedBuffer[i] ^ info.mask[i & 3];
      }
    }
    return {
      opcode: info.opcode,
      fin: info.fin,
      buffer: slicedBuffer,
      payloadLength: info.payloadLength,
      rest: buffer.subarray(info.startIndex + info.payloadLength)
    };
  }
  processData(data) {
    return __async(this, null, function* () {
      var _a, _b;
      const info = this.parseFrameHeaderInfo(data);
      const bodyLength = Buffer.byteLength(data) - info.startIndex;
      if (info.payloadLength > bodyLength) {
        const bytesLeft = info.payloadLength - bodyLength;
        const nextData = yield new Promise((resolve) => {
          var _a2;
          (_a2 = this.socket) == null ? void 0 : _a2.once("data", (data2) => {
            var _a3;
            if (data2.length > bytesLeft) {
              (_a3 = this.socket) == null ? void 0 : _a3.unshift(data2.subarray(bytesLeft));
              data2 = data2.subarray(0, bytesLeft);
            }
            resolve(data2);
          });
        });
        data = Buffer.concat([data, nextData]);
      }
      const headers = this.parseFrameHeader(info, data);
      switch (headers.opcode) {
        case 0: {
          this.continueInfo.buffer.push(headers.buffer);
          if (headers.fin) {
            this.emit(
              "message",
              this.continueInfo.type === 1 ? this.continueInfo.buffer.join("") : Buffer.concat(this.continueInfo.buffer).toString(),
              this.continueInfo.type === 1
            );
            this.continueInfo = {
              type: -1,
              buffer: []
            };
          }
          break;
        }
        case 1:
        case 2: {
          if (this.continueInfo.type !== -1 && this.continueInfo.type !== headers.opcode) {
            this.close(1002, "Invalid continuation frame");
            this.cleanup();
            return;
          }
          if (!headers.fin) {
            this.continueInfo.type = headers.opcode;
            this.continueInfo.buffer.push(headers.buffer);
          } else {
            this.emit(
              "message",
              headers.opcode === 1 ? headers.buffer.toString("utf8") : headers.buffer.toString("utf8"),
              headers.opcode === 1
            );
          }
          break;
        }
        case 8: {
          if (headers.buffer.length === 0) {
            this.emit("close", 1006, "");
          } else {
            const code = headers.buffer.readUInt16BE(0);
            const reason = headers.buffer.subarray(2).toString("utf-8");
            this.emit("close", code, reason);
          }
          this.cleanup();
          break;
        }
        case 9: {
          const pong = Buffer.allocUnsafe(2);
          pong[0] = 138;
          pong[1] = 0;
          (_a = this.socket) == null ? void 0 : _a.write(pong);
          break;
        }
        case 10: {
          this.emit("pong");
        }
        // eslint-disable-next-line no-fallthrough
        default: {
          this.close(1002, "Invalid opcode");
          this.cleanup();
          return;
        }
      }
      if (headers.rest.length > 0) (_b = this.socket) == null ? void 0 : _b.unshift(headers.rest);
    });
  }
};

// src/Utilities/AbstractDecoder.ts
var AbstractDecoder = class {
  /**
   * @public
   * Change the current potition in base64
   */
  changeBytes(bytes) {
    this.position += bytes;
    return this.position - bytes;
  }
  /**
   * @public
   * Read the byte on current buffer (some like boolean but only 0 and 1)
   */
  readByte() {
    return this.buffer[this.changeBytes(1)];
  }
  /**
   * @public
   * Read the unsigned 16 bit int (same like number)
   */
  readUnsignedShort() {
    const result = this.buffer.readUInt16BE(this.changeBytes(2));
    return result;
  }
  /**
   * @public
   * Read the unsigned 32 bit int (same like number)
   */
  readInt() {
    const result = this.buffer.readInt32BE(this.changeBytes(4));
    return result;
  }
  /**
   * @public
   * Read the bigint
   */
  readLong() {
    const msb = BigInt(this.readInt());
    const lsb = BigInt(this.readInt());
    return msb * BigInt(2 ** 32) + lsb;
  }
  /**
   * @public
   * Read UTF string (same like string)
   */
  readUTF() {
    const len = this.readUnsignedShort();
    const start = this.changeBytes(Number(len));
    const result = this.buffer.toString("utf8", start, Number(start) + Number(len));
    return result;
  }
};

// src/Utilities/LavalinkDecoder.ts
var LavalinkDecoder = class extends AbstractDecoder {
  constructor(track) {
    super();
    /** The current position of base64 string */
    this.position = 0;
    this.track = track;
    this.buffer = Buffer.from(track, "base64");
  }
  /** Get the decoded track with version detector */
  get getTrack() {
    try {
      const isVersioned = ((this.readInt() & 3221225472) >> 30 & 1) !== 0;
      const version2 = isVersioned ? Number(this.readByte()) : 1;
      switch (version2) {
        case 1:
          return this.trackVersionOne;
        case 2:
          return this.trackVersionTwo;
        case 3:
          return this.trackVersionThree;
        default:
          return null;
      }
    } catch (e) {
      return null;
    }
  }
  /** Get the decoded track with version 1 */
  get trackVersionOne() {
    try {
      return {
        encoded: this.track,
        info: {
          title: this.readUTF(),
          author: this.readUTF(),
          length: Number(this.readLong()),
          identifier: this.readUTF(),
          isSeekable: true,
          isStream: !!this.readByte(),
          uri: null,
          artworkUrl: null,
          isrc: null,
          sourceName: this.readUTF().toLowerCase(),
          position: Number(this.readLong())
        },
        pluginInfo: {}
      };
    } catch (e) {
      return null;
    }
  }
  /** Get the decoded track with version 2 */
  get trackVersionTwo() {
    try {
      return {
        encoded: this.track,
        info: {
          title: this.readUTF(),
          author: this.readUTF(),
          length: Number(this.readLong()),
          identifier: this.readUTF(),
          isSeekable: true,
          isStream: !!this.readByte(),
          uri: this.readByte() ? this.readUTF() : null,
          artworkUrl: null,
          isrc: null,
          sourceName: this.readUTF().toLowerCase(),
          position: Number(this.readLong())
        },
        pluginInfo: {}
      };
    } catch (e) {
      return null;
    }
  }
  /** Get the decoded track with version 3 */
  get trackVersionThree() {
    try {
      return {
        encoded: this.track,
        info: {
          title: this.readUTF(),
          author: this.readUTF(),
          length: Number(this.readLong()),
          identifier: this.readUTF(),
          isSeekable: true,
          isStream: !!this.readByte(),
          uri: this.readByte() ? this.readUTF() : null,
          artworkUrl: this.readByte() ? this.readUTF() : null,
          isrc: this.readByte() ? this.readUTF() : null,
          sourceName: this.readUTF().toLowerCase(),
          position: Number(this.readLong())
        },
        pluginInfo: {}
      };
    } catch (e) {
      return null;
    }
  }
};

// src/Drivers/Lavalink4.ts
var Lavalink4 = class extends AbstractDriver {
  constructor(manager, node) {
    super();
    this.manager = manager;
    this.node = node;
    this.id = "lavalink/v4/koinu";
    this.wsUrl = "";
    this.httpUrl = "";
    this.playerFunctions = new RainlinkFunctions();
    this.functions = new RainlinkFunctions();
    this.sessionId = null;
    this.wsUrl = `${this.node.options.secure ? "wss" : "ws"}://${this.node.options.host}:${this.node.options.port}/v4/websocket`;
    this.httpUrl = `${this.node.options.secure ? "https://" : "http://"}${this.node.options.host}:${this.node.options.port}/v4`;
    this.functions.set("decode", this.decode);
  }
  connect() {
    const isResume = this.manager.rainlinkOptions.options.resume;
    const headers = {
      Authorization: this.node.options.auth,
      "user-id": String(this.manager.id),
      "client-name": `${metadata.name}/${metadata.version} (${metadata.github})`,
      "user-agent": this.manager.rainlinkOptions.options.userAgent,
      "num-shards": String(this.manager.shardCount)
    };
    if (this.sessionId !== null && isResume) headers["session-id"] = this.sessionId;
    const ws = new RainlinkWebsocket(this.wsUrl, {
      legacy: this.node.options.legacyWS,
      headers
    });
    ws.on("open", () => {
      this.node.wsOpenEvent();
    });
    ws.on("message", (data) => this.wsMessageEvent(data));
    ws.on("error", (err) => this.node.wsErrorEvent(err));
    ws.on("close", (code, reason) => {
      this.node.wsCloseEvent(code, reason);
      ws.removeAllListeners();
    });
    this.wsClient = ws;
    return ws;
  }
  requester(options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      if (options.path.includes("/sessions") && this.sessionId == null)
        throw new Error("sessionId not initalized! Please wait for lavalink get connected!");
      const url = new URL(`${this.httpUrl}${options.path}`);
      if (options.params) url.search = new URLSearchParams(options.params).toString();
      if (options.data) {
        options.body = JSON.stringify(options.data);
      }
      const lavalinkHeaders = __spreadValues({
        authorization: this.node.options.auth,
        "user-agent": this.manager.rainlinkOptions.options.userAgent
      }, options.headers);
      options.headers = lavalinkHeaders;
      if (options.path == "/decodetrack") {
        const data = this.decode(
          options.params ? options.params.encodedTrack : ""
        );
        if (data) return data;
      }
      const res = yield fetch(url, options);
      if (res.status == 204) {
        this.debug(
          `${(_a = options.method) != null ? _a : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
        );
        return void 0;
      }
      if (res.status !== 200) {
        this.debug(
          `${(_b = options.method) != null ? _b : "GET"} ${options.path} payload=${options.body ? String(options.body) : "{}"}`
        );
        this.debug(
          `Something went wrong with lavalink server. Status code: ${res.status}
 Headers: ${util2.inspect(options.headers)}`
        );
        return void 0;
      }
      const finalData = yield res.json();
      this.debug(
        `${(_c = options.method) != null ? _c : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
      );
      return finalData;
    });
  }
  wsMessageEvent(data) {
    const wsData = JSON.parse(data.toString());
    this.node.wsMessageEvent(wsData);
  }
  debug(logs) {
    var _a;
    this.manager.emit(
      "debug" /* Debug */,
      `[Rainlink] / [Node @ ${(_a = this.node) == null ? void 0 : _a.options.name}] / [Driver] / [Lavalink4] | ${logs}`
    );
  }
  wsClose() {
    if (this.wsClient) this.wsClient.close(1006, "Self closed");
  }
  updateSession(sessionId, mode, timeout) {
    return __async(this, null, function* () {
      const options = {
        path: `/sessions/${sessionId}`,
        headers: { "content-type": "application/json" },
        method: "PATCH",
        data: {
          resuming: mode,
          timeout
        }
      };
      yield this.requester(options);
      this.debug(`Session updated! resume: ${mode}, timeout: ${timeout}`);
      return;
    });
  }
  decode(base64) {
    var _a;
    return (_a = new LavalinkDecoder(base64).getTrack) != null ? _a : void 0;
  }
};

// src/Node/RainlinkNode.ts
var RainlinkNode = class {
  /**
    * The lavalink server handler class
    * @param manager The rainlink manager
    * @param options The lavalink server options
    */
  constructor(manager, options) {
    /** The lavalink server online status */
    this.online = false;
    this.retryCounter = 0;
    /** The lavalink server connect state */
    this.state = 2 /* Closed */;
    this.sudoDisconnect = false;
    this.manager = manager;
    this.options = options;
    const getDriver = this.manager.drivers.filter(
      (driver) => driver.prototype.id === options.driver
    );
    if (!getDriver || getDriver.length == 0) {
      this.debug("No driver was found, using lavalink v4 driver instead");
      this.driver = new Lavalink4(manager, this);
    } else {
      this.debug(`Now using driver: ${getDriver[0].prototype.id}`);
      this.driver = new getDriver[0](manager, this);
    }
    const customRest = this.manager.rainlinkOptions.options.structures && this.manager.rainlinkOptions.options.structures.rest;
    this.rest = customRest ? new customRest(manager, options, this) : new RainlinkRest(manager, options, this);
    this.wsEvent = new RainlinkPlayerEvents();
    this.stats = {
      players: 0,
      playingPlayers: 0,
      uptime: 0,
      memory: {
        free: 0,
        used: 0,
        allocated: 0,
        reservable: 0
      },
      cpu: {
        cores: 0,
        systemLoad: 0,
        lavalinkLoad: 0
      },
      frameStats: {
        sent: 0,
        nulled: 0,
        deficit: 0
      }
    };
  }
  /** Connect this lavalink server */
  connect() {
    return this.driver.connect();
  }
  /** @ignore */
  wsOpenEvent() {
    this.clean(true);
    this.state = 0 /* Connected */;
    this.debug(`Node connected! URL: ${this.driver.wsUrl}`);
    this.manager.emit("nodeConnect" /* NodeConnect */, this);
  }
  /** @ignore */
  wsMessageEvent(data) {
    var _a;
    switch (data.op) {
      case "ready" /* Ready */: {
        const isResume = this.manager.rainlinkOptions.options.resume;
        const timeout = (_a = this.manager.rainlinkOptions.options) == null ? void 0 : _a.resumeTimeout;
        this.driver.sessionId = data.sessionId;
        const customRest = this.manager.rainlinkOptions.options.structures && this.manager.rainlinkOptions.options.structures.rest;
        this.rest = customRest ? new customRest(this.manager, this.options, this) : new RainlinkRest(this.manager, this.options, this);
        if (isResume && timeout) {
          this.driver.updateSession(data.sessionId, isResume, timeout);
        }
        break;
      }
      case "event" /* Event */: {
        this.wsEvent.initial(data, this.manager);
        break;
      }
      case "playerUpdate" /* PlayerUpdate */: {
        this.wsEvent.initial(data, this.manager);
        break;
      }
      case "stats" /* Status */: {
        this.stats = this.updateStatusData(data);
        break;
      }
    }
  }
  /** @ignore */
  wsErrorEvent(logs) {
    this.debug(`Node errored! URL: ${this.driver.wsUrl}`);
    this.manager.emit("nodeError" /* NodeError */, this, logs);
  }
  /** @ignore */
  wsCloseEvent(code, reason) {
    return __async(this, null, function* () {
      this.online = false;
      this.state = 1 /* Disconnected */;
      this.debug(`Node disconnected! URL: ${this.driver.wsUrl}`);
      this.manager.emit("nodeDisconnect" /* NodeDisconnect */, this, code, reason);
      if (!this.sudoDisconnect && this.retryCounter !== this.manager.rainlinkOptions.options.retryCount) {
        yield setTimeout2(this.manager.rainlinkOptions.options.retryTimeout);
        this.retryCounter = this.retryCounter + 1;
        this.reconnect(true);
        return;
      }
      this.nodeClosed();
      return;
    });
  }
  nodeClosed() {
    this.manager.emit("nodeClosed" /* NodeClosed */, this);
    this.debug(`Node closed! URL: ${this.driver.wsUrl}`);
    this.clean();
  }
  updateStatusData(data) {
    var _a, _b, _c, _d, _e, _f;
    return {
      players: (_a = data.players) != null ? _a : this.stats.players,
      playingPlayers: (_b = data.playingPlayers) != null ? _b : this.stats.playingPlayers,
      uptime: (_c = data.uptime) != null ? _c : this.stats.uptime,
      memory: (_d = data.memory) != null ? _d : this.stats.memory,
      cpu: (_e = data.cpu) != null ? _e : this.stats.cpu,
      frameStats: (_f = data.frameStats) != null ? _f : this.stats.frameStats
    };
  }
  /** Disconnect this lavalink server */
  disconnect() {
    this.sudoDisconnect = true;
    this.driver.wsClose();
  }
  /** Reconnect back to this lavalink server */
  reconnect(noClean) {
    var _a;
    if (!noClean) this.clean();
    this.debug(`Node is trying to reconnect! URL: ${this.driver.wsUrl}`);
    (_a = this.manager) == null ? void 0 : _a.emit("nodeReconnect" /* NodeReconnect */, this);
    this.driver.connect();
  }
  /** Clean all the lavalink server state and set to default value */
  clean(online = false) {
    this.sudoDisconnect = false;
    this.retryCounter = 0;
    this.online = online;
    this.state = 2 /* Closed */;
  }
  debug(logs) {
    this.manager.emit("debug" /* Debug */, `[Rainlink] / [Node @ ${this.options.name}] | ${logs}`);
  }
};

// src/Manager/RainlinkNodeManager.ts
var RainlinkNodeManager = class extends RainlinkDatabase {
  /**
    * The main class for handling lavalink servers
    * @param manager
    */
  constructor(manager) {
    super();
    this.manager = manager;
  }
  /**
    * Add a new Node.
    * @returns RainlinkNode
    */
  add(node) {
    const newNode = new RainlinkNode(this.manager, node);
    newNode.connect();
    this.set(node.name, newNode);
    this.debug(`Node ${node.name} added to manager!`);
    return newNode;
  }
  /**
    * Get a least used node.
    * @returns RainlinkNode
    */
  getLeastUsed(customNodeArray) {
    return __async(this, null, function* () {
      const nodes = customNodeArray ? customNodeArray : this.values;
      if (this.manager.rainlinkOptions.options.nodeResolver) {
        const resolverData = yield this.manager.rainlinkOptions.options.nodeResolver(nodes);
        if (resolverData) return resolverData;
      }
      const onlineNodes = nodes.filter((node) => node.state === 0 /* Connected */);
      if (!onlineNodes.length) throw new Error("No nodes are online");
      const temp = yield Promise.all(
        onlineNodes.map((node) => __async(this, null, function* () {
          const stats = yield node.rest.getStatus();
          return !stats ? { players: 0, node } : { players: stats.players, node };
        }))
      );
      temp.sort((a, b) => a.players - b.players);
      return temp[0].node;
    });
  }
  /**
    * Get all current nodes
    * @returns RainlinkNode[]
    */
  all() {
    return this.values;
  }
  /**
    * Remove a node.
    * @returns void
    */
  remove(name) {
    const node = this.get(name);
    if (node) {
      node.disconnect();
      this.delete(name);
      this.debug(`Node ${name} removed from manager!`);
    }
    return;
  }
  debug(logs) {
    this.manager.emit("debug" /* Debug */, `[Rainlink] / [NodeManager] | ${logs}`);
  }
};

// src/Drivers/Lavalink3.ts
import util3 from "node:util";
var Lavalink3loadType = /* @__PURE__ */ ((Lavalink3loadType2) => {
  Lavalink3loadType2["TRACK_LOADED"] = "TRACK_LOADED";
  Lavalink3loadType2["PLAYLIST_LOADED"] = "PLAYLIST_LOADED";
  Lavalink3loadType2["SEARCH_RESULT"] = "SEARCH_RESULT";
  Lavalink3loadType2["NO_MATCHES"] = "NO_MATCHES";
  Lavalink3loadType2["LOAD_FAILED"] = "LOAD_FAILED";
  return Lavalink3loadType2;
})(Lavalink3loadType || {});
var Lavalink3 = class extends AbstractDriver {
  constructor(manager, node) {
    super();
    this.manager = manager;
    this.node = node;
    this.id = "lavalink/v3/koto";
    this.wsUrl = "";
    this.httpUrl = "";
    this.playerFunctions = new RainlinkFunctions();
    this.functions = new RainlinkFunctions();
    this.sessionId = null;
    this.wsUrl = `${this.node.options.secure ? "wss" : "ws"}://${this.node.options.host}:${this.node.options.port}/`;
    this.httpUrl = `${this.node.options.secure ? "https://" : "http://"}${this.node.options.host}:${this.node.options.port}`;
    this.functions.set("decode", this.decode);
  }
  connect() {
    const isResume = this.manager.rainlinkOptions.options.resume;
    const headers = {
      Authorization: this.node.options.auth,
      "user-id": String(this.manager.id),
      "client-name": `${metadata.name}/${metadata.version} (${metadata.github})`,
      "user-agent": this.manager.rainlinkOptions.options.userAgent,
      "num-shards": this.manager.shardCount
    };
    if (this.sessionId !== null && isResume) headers["session-id"] = this.sessionId;
    const ws = new RainlinkWebsocket(this.wsUrl, {
      legacy: this.node.options.legacyWS,
      headers
    });
    ws.on("open", () => {
      this.node.wsOpenEvent();
    });
    ws.on("message", (data) => this.wsMessageEvent(data));
    ws.on("error", (err) => this.node.wsErrorEvent(err));
    ws.on("close", (code, reason) => {
      this.node.wsCloseEvent(code, reason);
      ws.removeAllListeners();
    });
    this.wsClient = ws;
    return ws;
  }
  requester(options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      const url = new URL(`${this.httpUrl}${options.path}`);
      if (options.params) url.search = new URLSearchParams(options.params).toString();
      if (options.rawReqData && options.path.includes("/sessions")) {
        this.convertToV3websocket(options.rawReqData);
        return;
      }
      if (options.data) {
        this.convertToV3request(options.data);
        options.body = JSON.stringify(options.data);
      }
      if (options.path.includes("/sessions//")) return void 0;
      if (/\/sessions\/(.*)\/players\/(.*)/.test(options.path) || options.method && options.method == "DELETE")
        return void 0;
      const lavalinkHeaders = __spreadValues({
        authorization: this.node.options.auth,
        "user-agent": this.manager.rainlinkOptions.options.userAgent
      }, options.headers);
      options.headers = lavalinkHeaders;
      if (this.sessionId) url.pathname = "/v3" + url.pathname;
      if (options.path == "/decodetrack") {
        const data = this.decode(
          options.params ? options.params.encodedTrack : ""
        );
        if (data) return data;
      }
      const res = yield fetch(url, options);
      if (res.status == 204) {
        this.debug(
          `${(_a = options.method) != null ? _a : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
        );
        return void 0;
      }
      if (res.status !== 200) {
        this.debug(
          `${(_b = options.method) != null ? _b : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
        );
        this.debug(
          `Something went wrong with lavalink server. Status code: ${res.status}
 Headers: ${util3.inspect(options.headers)}`
        );
        return void 0;
      }
      const preFinalData = yield res.json();
      let finalData = preFinalData;
      if (finalData.loadType) {
        finalData = this.convertV4trackResponse(finalData);
      }
      this.debug(
        `${(_c = options.method) != null ? _c : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
      );
      return finalData;
    });
  }
  convertToV3websocket(data) {
    let isPlaySent;
    if (!data) return;
    if (data.playerOptions.voice)
      this.wsSendData({
        op: "voiceUpdate",
        guildId: data.guildId,
        sessionId: data.playerOptions.voice.sessionId,
        event: data.playerOptions.voice
      });
    if (data.playerOptions.track && data.playerOptions.track.encoded && data.playerOptions.track.length !== 0) {
      isPlaySent = true;
      this.wsSendData({
        op: "play",
        guildId: data.guildId,
        track: data.playerOptions.track.encoded,
        startTime: data.playerOptions.position,
        endTime: data.playerOptions.track.length,
        volume: data.playerOptions.volume,
        noReplace: data.noReplace,
        pause: data.playerOptions.paused
      });
    }
    if (data.playerOptions.track && data.playerOptions.track.encoded == null && data.playerOptions.track.length === 0)
      this.wsSendData({
        op: "destroy",
        guildId: data.guildId
      });
    if (data.playerOptions.track && data.playerOptions.track.encoded == null)
      this.wsSendData({
        op: "stop",
        guildId: data.guildId
      });
    if (isPlaySent) return isPlaySent = false;
    if (data.playerOptions.paused === false || data.playerOptions.paused === true)
      this.wsSendData({
        op: "pause",
        guildId: data.guildId,
        pause: data.playerOptions.paused
      });
    if (data.playerOptions.position)
      this.wsSendData({
        op: "seek",
        guildId: data.guildId,
        position: data.playerOptions.position
      });
    if (data.playerOptions.volume)
      this.wsSendData({
        op: "volume",
        guildId: data.guildId,
        volume: data.playerOptions.volume
      });
    if (data.playerOptions.filters)
      this.wsSendData(__spreadValues({
        op: "filters",
        guildId: data.guildId
      }, data.playerOptions.filters));
  }
  checkUpdateExist(data) {
    return data.track || data.identifier || data.position || data.endTime || data.volume || data.paused || data.filters || data.voice;
  }
  wsSendData(data) {
    if (!this.wsClient) return;
    const jsonData = JSON.stringify(data);
    this.wsClient.send(jsonData);
    return;
  }
  wsMessageEvent(data) {
    const wsData = JSON.parse(data.toString());
    if (wsData.reason) wsData.reason = wsData.reason.toLowerCase();
    if (wsData.reason == "LOAD_FAILED") wsData.reason = "loadFailed";
    this.node.wsMessageEvent(wsData);
  }
  updateSession(sessionId, mode, timeout) {
    return __async(this, null, function* () {
      if (!sessionId) {
        this.wsSendData({
          op: "configureResuming",
          key: "rainlink/lavalink/v3/koto/legacy",
          timeout: 60
        });
        this.debug(`Session updated! resume: ${mode}, timeout: ${timeout}`);
        return;
      }
      const options = {
        path: `/sessions/${sessionId}`,
        headers: { "content-type": "application/json" },
        method: "PATCH",
        data: {
          resumingKey: sessionId,
          timeout
        }
      };
      yield this.requester(options);
      this.debug(`Session updated! resume: ${mode}, timeout: ${timeout}`);
      return;
    });
  }
  debug(logs) {
    var _a;
    this.manager.emit(
      "debug" /* Debug */,
      `[Rainlink] / [Node @ ${(_a = this.node) == null ? void 0 : _a.options.name}] / [Driver] / [Lavalink3] | ${logs}`
    );
  }
  wsClose() {
    if (this.wsClient) this.wsClient.close(1006, "Self closed");
  }
  testJSON(text) {
    if (typeof text !== "string") {
      return false;
    }
    try {
      JSON.parse(text);
      return true;
    } catch (e) {
      return false;
    }
  }
  convertToV3request(data) {
    if (!data) return;
    if (data.track && data.track.encoded !== void 0) {
      data.encodedTrack = data.track.encoded;
      delete data.track;
    }
    return;
  }
  convertV4trackResponse(v3data) {
    if (!v3data) return {};
    if (v3data.loadType == "LOAD_FAILED" /* LOAD_FAILED */) v3data.loadType = "error" /* ERROR */;
    if (v3data.loadType.includes("PLAYLIST_LOADED")) {
      v3data.loadType = "playlist" /* PLAYLIST */;
      const convertedArray = [];
      for (let i = 0; i < v3data.tracks.length; i++) {
        convertedArray.push(this.buildV4track(v3data.tracks[i]));
      }
      v3data.data = {
        info: v3data.playlistInfo,
        tracks: convertedArray
      };
      delete v3data.tracks;
      return v3data;
    }
    if (v3data.loadType == "SEARCH_RESULT" /* SEARCH_RESULT */) {
      v3data.loadType = "search" /* SEARCH */;
      v3data.data = v3data.tracks;
      for (let i = 0; i < v3data.data.length; i++) {
        v3data.data[i] = this.buildV4track(v3data.data[i]);
      }
      delete v3data.tracks;
      delete v3data.playlistInfo;
    }
    if (v3data.loadType == "TRACK_LOADED" /* TRACK_LOADED */) {
      v3data.loadType = "track" /* TRACK */;
      v3data.data = this.buildV4track(v3data.tracks[0]);
      delete v3data.tracks;
    }
    if (v3data.loadType == "NO_MATCHES" /* NO_MATCHES */) v3data.loadType = "empty" /* EMPTY */;
    return v3data;
  }
  buildV4track(v3data) {
    return {
      encoded: v3data.track,
      info: {
        sourceName: v3data.info.sourceName,
        identifier: v3data.info.identifier,
        isSeekable: v3data.info.isSeekable,
        author: v3data.info.author,
        length: v3data.info.length,
        isStream: v3data.info.isStream,
        position: v3data.info.position,
        title: v3data.info.title,
        uri: v3data.info.uri,
        artworkUrl: void 0
      },
      pluginInfo: void 0
    };
  }
  decode(base64) {
    var _a;
    return (_a = new LavalinkDecoder(base64).getTrack) != null ? _a : void 0;
  }
};

// src/Drivers/Nodelink2.ts
import util4 from "node:util";
var Nodelink2loadType = /* @__PURE__ */ ((Nodelink2loadType2) => {
  Nodelink2loadType2["SHORTS"] = "shorts";
  Nodelink2loadType2["ALBUM"] = "album";
  Nodelink2loadType2["ARTIST"] = "artist";
  Nodelink2loadType2["SHOW"] = "show";
  Nodelink2loadType2["EPISODE"] = "episode";
  Nodelink2loadType2["STATION"] = "station";
  Nodelink2loadType2["PODCAST"] = "podcast";
  return Nodelink2loadType2;
})(Nodelink2loadType || {});
var Nodelink2 = class extends AbstractDriver {
  constructor(manager, node) {
    super();
    this.manager = manager;
    this.node = node;
    this.id = "nodelink/v2/nari";
    this.wsUrl = "";
    this.httpUrl = "";
    this.sessionId = null;
    this.playerFunctions = new RainlinkFunctions();
    this.functions = new RainlinkFunctions();
    this.wsUrl = `${this.node.options.secure ? "wss" : "ws"}://${this.node.options.host}:${this.node.options.port}/v4/websocket`;
    this.httpUrl = `${this.node.options.secure ? "https://" : "http://"}${this.node.options.host}:${this.node.options.port}/v4`;
    this.playerFunctions.set("getLyric", this.getLyric);
    this.functions.set("decode", this.decode);
  }
  connect() {
    const isResume = this.manager.rainlinkOptions.options.resume;
    const headers = {
      Authorization: this.node.options.auth,
      "user-id": String(this.manager.id),
      "accept-encoding": process.isBun ? "gzip, deflate" : "br, gzip, deflate",
      "client-name": `${metadata.name}/${metadata.version} (${metadata.github})`,
      "user-agent": this.manager.rainlinkOptions.options.userAgent,
      "num-shards": String(this.manager.shardCount)
    };
    if (this.sessionId !== null && isResume) headers["session-id"] = this.sessionId;
    const ws = new RainlinkWebsocket(this.wsUrl, {
      legacy: this.node.options.legacyWS,
      headers
    });
    ws.on("open", () => {
      this.node.wsOpenEvent();
    });
    ws.on("message", (data) => this.wsMessageEvent(data));
    ws.on("error", (err) => this.node.wsErrorEvent(err));
    ws.on("close", (code, reason) => {
      this.node.wsCloseEvent(code, reason);
      ws.removeAllListeners();
    });
    this.wsClient = ws;
    return ws;
  }
  requester(options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      if (options.path.includes("/sessions") && this.sessionId == null)
        throw new Error("sessionId not initalized! Please wait for nodelink get connected!");
      const url = new URL(`${this.httpUrl}${options.path}`);
      if (options.params) url.search = new URLSearchParams(options.params).toString();
      if (options.data) {
        options.body = JSON.stringify(options.data);
      }
      const lavalinkHeaders = __spreadValues({
        authorization: this.node.options.auth,
        "user-agent": this.manager.rainlinkOptions.options.userAgent,
        "accept-encoding": process.isBun ? "gzip, deflate" : "br, gzip, deflate"
      }, options.headers);
      options.headers = lavalinkHeaders;
      if (options.path == "/decodetrack") {
        const data = this.decode(
          options.params ? options.params.encodedTrack : ""
        );
        if (data) return data;
      }
      const res = yield fetch(url, options);
      if (res.status == 204) {
        this.debug(
          `${(_a = options.method) != null ? _a : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
        );
        return void 0;
      }
      if (res.status !== 200) {
        this.debug(
          `${(_b = options.method) != null ? _b : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
        );
        this.debug(
          `Something went wrong with nodelink server. Status code: ${res.status}
 Headers: ${util4.inspect(options.headers)}`
        );
        return void 0;
      }
      const preFinalData = yield res.json();
      let finalData = preFinalData;
      if (finalData.loadType) {
        finalData = this.convertV4trackResponse(finalData);
      }
      this.debug(
        `${(_c = options.method) != null ? _c : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
      );
      return finalData;
    });
  }
  wsMessageEvent(data) {
    const wsData = JSON.parse(data.toString());
    this.node.wsMessageEvent(wsData);
  }
  debug(logs) {
    var _a;
    this.manager.emit(
      "debug" /* Debug */,
      `[Rainlink] / [Node @ ${(_a = this.node) == null ? void 0 : _a.options.name}] / [Driver] / [Nodelink2] | ${logs}`
    );
  }
  wsClose() {
    if (this.wsClient) this.wsClient.close(1006, "Self closed");
  }
  convertV4trackResponse(nl2Data) {
    if (!nl2Data) return {};
    switch (nl2Data.loadType) {
      case "shorts" /* SHORTS */: {
        nl2Data.loadType = "track" /* TRACK */;
        return nl2Data;
      }
      case "album" /* ALBUM */: {
        nl2Data.loadType = "playlist" /* PLAYLIST */;
        return nl2Data;
      }
      case "artist" /* ARTIST */: {
        nl2Data.loadType = "playlist" /* PLAYLIST */;
        return nl2Data;
      }
      case "episode" /* EPISODE */: {
        nl2Data.loadType = "playlist" /* PLAYLIST */;
        return nl2Data;
      }
      case "station" /* STATION */: {
        nl2Data.loadType = "playlist" /* PLAYLIST */;
        return nl2Data;
      }
      case "podcast" /* PODCAST */: {
        nl2Data.loadType = "playlist" /* PLAYLIST */;
        return nl2Data;
      }
      case "show" /* SHOW */: {
        nl2Data.loadType = "playlist" /* PLAYLIST */;
        return nl2Data;
      }
    }
    return nl2Data;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  updateSession(sessionId, mode, timeout) {
    return __async(this, null, function* () {
      this.debug("WARNING: Nodelink doesn't support resuming, set resume to true is useless");
      return;
    });
  }
  getLyric(player, trackName, language) {
    return __async(this, null, function* () {
      var _a;
      let track = String((_a = player.queue.current) == null ? void 0 : _a.encoded);
      if (trackName) {
        const nodeName = player.node.options.name;
        const res = yield player.search("trackName", { nodeName });
        if (res.tracks.length == 0) return void 0;
        track = res.tracks[0].encoded;
      }
      const options = {
        path: "/loadlyrics",
        params: {
          encodedTrack: track,
          language: language ? language : "en"
        },
        headers: { "content-type": "application/json" },
        method: "GET"
      };
      const data = yield player.node.driver.requester(options);
      return data;
    });
  }
  testJSON(text) {
    if (typeof text !== "string") {
      return false;
    }
    try {
      JSON.parse(text);
      return true;
    } catch (e) {
      return false;
    }
  }
  decode(base64) {
    var _a;
    return (_a = new LavalinkDecoder(base64).getTrack) != null ? _a : void 0;
  }
};

// src/Drivers/FrequenC.ts
import util5 from "node:util";
var FrequenC = class extends AbstractDriver {
  constructor(manager, node) {
    super();
    this.manager = manager;
    this.node = node;
    this.id = "frequenc/v1/miku";
    this.wsUrl = "";
    this.httpUrl = "";
    this.playerFunctions = new RainlinkFunctions();
    this.functions = new RainlinkFunctions();
    this.sessionId = null;
    this.wsUrl = `${this.node.options.secure ? "wss" : "ws"}://${this.node.options.host}:${this.node.options.port}/v1/websocket`;
    this.httpUrl = `${this.node.options.secure ? "https://" : "http://"}${this.node.options.host}:${this.node.options.port}/v1`;
    this.functions.set("decode", this.decode);
  }
  connect() {
    const ws = new RainlinkWebsocket(this.wsUrl, {
      legacy: this.node.options.legacyWS,
      headers: {
        authorization: this.node.options.auth,
        "user-id": String(this.manager.id),
        "client-info": `${metadata.name}/${metadata.version} (${metadata.github})`,
        "user-agent": this.manager.rainlinkOptions.options.userAgent,
        "num-shards": this.manager.shardCount
      }
    });
    ws.on("open", () => {
      this.node.wsOpenEvent();
    });
    ws.on("message", (data) => this.wsMessageEvent(data));
    ws.on("error", (err) => this.node.wsErrorEvent(err));
    ws.on("close", (code, reason) => {
      this.node.wsCloseEvent(code, reason);
      ws.removeAllListeners();
    });
    this.wsClient = ws;
    return ws;
  }
  requester(options) {
    return __async(this, null, function* () {
      var _a, _b, _c;
      if (options.path.includes("/sessions") && this.sessionId == null)
        throw new Error("sessionId not initalized! Please wait for lavalink get connected!");
      const url = new URL(`${this.httpUrl}${options.path}`);
      if (options.params) url.search = new URLSearchParams(options.params).toString();
      if (options.data) {
        const converted = this.camelToSnake(options.data);
        options.body = JSON.stringify(converted);
      }
      const lavalinkHeaders = __spreadValues({
        authorization: this.node.options.auth
      }, options.headers);
      options.headers = lavalinkHeaders;
      if (options.body && JSON.stringify(options.body) == "{}") delete options.body;
      if (options.path == "/decodetrack") {
        const data = this.decode(
          options.params ? options.params.encodedTrack : ""
        );
        if (data) return data;
      }
      const res = yield fetch(url, options);
      if (res.status == 204) {
        this.debug(
          `${(_a = options.method) != null ? _a : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
        );
        return void 0;
      }
      if (res.status !== 200) {
        this.debug(
          `${(_b = options.method) != null ? _b : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
        );
        this.debug(
          `Something went wrong with frequenc server. Status code: ${res.status}
 Headers: ${util5.inspect(options.headers)}`
        );
        return void 0;
      }
      let finalData;
      if (res.headers.get("content-type") == "application/json") finalData = yield res.json();
      else finalData = { rawData: yield res.text() };
      this.debug(
        `${(_c = options.method) != null ? _c : "GET"} ${url.pathname + url.search} payload=${options.body ? String(options.body) : "{}"}`
      );
      return finalData;
    });
  }
  wsMessageEvent(data) {
    const wsData = this.snakeToCamel(JSON.parse(data.toString()));
    this.node.wsMessageEvent(wsData);
  }
  debug(logs) {
    var _a;
    this.manager.emit(
      "debug" /* Debug */,
      `[Rainlink] / [Node @ ${(_a = this.node) == null ? void 0 : _a.options.name}] / [Driver] / [FrequenC1] | ${logs}`
    );
  }
  wsClose() {
    if (this.wsClient) this.wsClient.close(1006, "Self closed");
  }
  updateSession(sessionId, mode, timeout) {
    return __async(this, null, function* () {
      const options = {
        path: `/sessions/${sessionId}`,
        headers: { "content-type": "application/json" },
        method: "PATCH",
        data: {
          resuming: mode,
          timeout
        }
      };
      yield this.requester(options);
      this.debug(`Session updated! resume: ${mode}, timeout: ${timeout}`);
      return;
    });
  }
  camelToSnake(obj) {
    if (typeof obj !== "object") return {};
    if (!obj || JSON.stringify(obj) == "{}") return {};
    const allKeys = Object.keys(obj);
    const regex = /^([a-z]{1,})(_[a-z0-9]{1,})*$/;
    for (const key of allKeys) {
      let newKey;
      if (!regex.test(key)) {
        newKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
        obj[newKey] = obj[key];
        delete obj[key];
      }
      if (newKey && typeof obj[newKey] !== "object" && typeof obj[key] !== "object") continue;
      newKey ? this.camelToSnake(obj[newKey]) : this.camelToSnake(obj[key]);
    }
    return obj;
  }
  snakeToCamel(obj) {
    if (typeof obj !== "object") return {};
    if (!obj || JSON.stringify(obj) == "{}") return {};
    const allKeys = Object.keys(obj);
    for (const key of allKeys) {
      let newKey;
      if (/([-_][a-z])/.test(key)) {
        newKey = key.toLowerCase().replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace("-", "").replace("_", ""));
        obj[newKey] = obj[key];
        delete obj[key];
      }
      if (newKey && typeof obj[newKey] !== "object" && typeof obj[key] !== "object") continue;
      newKey ? this.snakeToCamel(obj[newKey]) : this.snakeToCamel(obj[key]);
    }
    return obj;
  }
  decode(base64) {
    var _a;
    return (_a = new Decoder(base64).getTrack) != null ? _a : void 0;
  }
};
var Decoder = class extends AbstractDecoder {
  constructor(track) {
    super();
    this.track = track;
    this.position = 0;
    this.buffer = Buffer.from(track, "base64");
  }
  get getTrack() {
    try {
      this.readInt();
      this.readByte();
      return {
        encoded: this.track,
        info: {
          title: this.readUTF(),
          author: this.readUTF(),
          length: Number(this.readLong()),
          identifier: this.readUTF(),
          isSeekable: true,
          isStream: this.readByte() === 1,
          uri: this.readUTF(),
          artworkUrl: this.readByte() === 1 ? this.readUTF() : null,
          isrc: this.readByte() === 1 ? this.readUTF() : null,
          sourceName: this.readUTF().toLowerCase(),
          position: 0
        },
        pluginInfo: {}
      };
    } catch (e) {
      return null;
    }
  }
};

// src/Rainlink.ts
var Rainlink = class extends EventEmitter3 {
  /**
    * The main class that handle all works in lavalink server.
    * Call this class by using new Rainlink(your_params) to use!
    * @param options The main ranlink options
    */
  constructor(options) {
    var _a, _b;
    super();
    /**
      * The current bott's shard count
      */
    this.shardCount = 1;
    if (!options.library)
      throw new Error(
        "Please set an new lib to connect, example: \nlibrary: new Library.DiscordJS(client) "
      );
    this.library = options.library.set(this);
    this.drivers = [Lavalink3, Nodelink2, Lavalink4, FrequenC];
    this.rainlinkOptions = options;
    this.rainlinkOptions.options = this.mergeDefault(
      this.defaultOptions,
      (_a = this.rainlinkOptions.options) != null ? _a : {}
    );
    if (this.rainlinkOptions.options.additionalDriver && ((_b = this.rainlinkOptions.options.additionalDriver) == null ? void 0 : _b.length) !== 0)
      this.drivers.push(...this.rainlinkOptions.options.additionalDriver);
    this.nodes = new RainlinkNodeManager(this);
    this.players = new RainlinkPlayerManager(this);
    this.voices = new RainlinkDatabase();
    this.searchEngines = new RainlinkDatabase();
    this.searchPlugins = new RainlinkDatabase();
    this.plugins = new RainlinkDatabase();
    this.initialSearchEngines();
    if (!this.rainlinkOptions.options.defaultSearchEngine || this.rainlinkOptions.options.defaultSearchEngine.length == 0)
      this.rainlinkOptions.options.defaultSearchEngine == "youtube";
    if (this.rainlinkOptions.plugins) {
      for (const [, plugin] of this.rainlinkOptions.plugins.entries()) {
        if (!plugin.isRainlinkPlugin)
          throw new Error("Plugin must be an instance of RainlinkPlugin or SourceRainlinkPlugin");
        plugin.load(this);
        this.plugins.set(plugin.name(), plugin);
        if (plugin.type() == "sourceResolver" /* SourceResolver */) {
          const newPlugin = plugin;
          const sourceName = newPlugin.sourceName();
          const sourceIdentify = newPlugin.sourceIdentify();
          this.searchEngines.set(sourceName, sourceIdentify);
          this.searchPlugins.set(sourceName, newPlugin);
        }
      }
    }
    this.library.listen(this.rainlinkOptions.nodes);
  }
  initialSearchEngines() {
    for (const data of SourceIDs) {
      this.searchEngines.set(data.name, data.id);
    }
  }
  /**
    * Create a new player.
    * @returns RainlinkNode
    */
  create(options) {
    return __async(this, null, function* () {
      return yield this.players.create(options);
    });
  }
  /**
    * Destroy a specific player.
    * @returns void
    */
  destroy(guildId) {
    return __async(this, null, function* () {
      this.players.destroy(guildId);
    });
  }
  /**
    * Search a specific track.
    * @returns RainlinkSearchResult
    */
  search(query, options) {
    return __async(this, null, function* () {
      var _a, _b;
      const node = options && (options == null ? void 0 : options.nodeName) ? (_a = this.nodes.get(options.nodeName)) != null ? _a : yield this.nodes.getLeastUsed() : yield this.nodes.getLeastUsed();
      if (!node) throw new Error("No node is available");
      let pluginData;
      const directSearchRegex = /directSearch=(.*)/;
      const isDirectSearch = directSearchRegex.exec(query);
      const isUrl = /^https?:\/\/.*/.test(query);
      const pluginSearch = this.searchPlugins.get(String(options == null ? void 0 : options.engine));
      if (options && options.engine && options.engine !== null && pluginSearch && isDirectSearch == null) {
        pluginData = yield pluginSearch.searchDirect(query, options);
        if (pluginData.tracks.length !== 0) return pluginData;
      }
      const source = options && (options == null ? void 0 : options.engine) ? this.searchEngines.get(options.engine) : this.searchEngines.get(
        this.rainlinkOptions.options.defaultSearchEngine ? this.rainlinkOptions.options.defaultSearchEngine : "youtube"
      );
      const finalQuery = isDirectSearch !== null ? isDirectSearch[1] : !isUrl ? `${source}search:${query}` : query;
      const result = yield node.rest.resolver(finalQuery).catch(() => null);
      if (!result || result.loadType === "empty" /* EMPTY */) {
        return this.buildSearch(void 0, [], "SEARCH" /* SEARCH */);
      }
      let loadType;
      let normalizedData = { tracks: [] };
      switch (result.loadType) {
        case "track" /* TRACK */: {
          loadType = "TRACK" /* TRACK */;
          normalizedData.tracks = [result.data];
          break;
        }
        case "playlist" /* PLAYLIST */: {
          loadType = "PLAYLIST" /* PLAYLIST */;
          normalizedData = {
            playlistName: result.data.info.name,
            tracks: result.data.tracks
          };
          break;
        }
        case "search" /* SEARCH */: {
          loadType = "SEARCH" /* SEARCH */;
          normalizedData.tracks = result.data;
          break;
        }
        default: {
          loadType = "SEARCH" /* SEARCH */;
          normalizedData.tracks = [];
          break;
        }
      }
      this.emit(
        "debug" /* Debug */,
        `[Rainlink] / [Search] | Searched ${query}; Track results: ${normalizedData.tracks.length}`
      );
      return this.buildSearch(
        (_b = normalizedData.playlistName) != null ? _b : void 0,
        normalizedData.tracks.map(
          (track) => new RainlinkTrack(
            track,
            options && options.requester ? options.requester : void 0,
            node.driver.id
          )
        ),
        loadType
      );
    });
  }
  buildSearch(playlistName, tracks = [], type) {
    return {
      playlistName,
      tracks,
      type: type != null ? type : "SEARCH" /* SEARCH */
    };
  }
  get defaultOptions() {
    return {
      additionalDriver: [],
      retryTimeout: 3e3,
      retryCount: 15,
      voiceConnectionTimeout: 15e3,
      defaultSearchEngine: "youtube",
      defaultVolume: 100,
      searchFallback: {
        enable: true,
        engine: "soundcloud"
      },
      resume: false,
      userAgent: `Discord/Bot/${metadata.name}/${metadata.version} (${metadata.github})`,
      nodeResolver: void 0,
      structures: {
        player: void 0,
        rest: void 0,
        queue: void 0,
        filter: void 0
      },
      resumeTimeout: 300
    };
  }
  // Modded from:
  // https://github.com/shipgirlproject/Shoukaku/blob/2677ecdf123ffef1c254c2113c5342b250ac4396/src/Utils.ts#L9-L23
  mergeDefault(def, given) {
    if (!given) return def;
    const defaultKeys = Object.keys(def);
    for (const key in given) {
      if (defaultKeys.includes(key)) continue;
      if (this.isNumber(key)) continue;
      delete given[key];
    }
    for (const key of defaultKeys) {
      if (Array.isArray(given[key]) && given[key] !== null && given[key] !== void 0) {
        if (given[key].length == 0) given[key] = def[key];
      }
      if (def[key] === null || typeof def[key] === "string" && def[key].length === 0) {
        if (!given[key]) given[key] = def[key];
      }
      if (given[key] === null || given[key] === void 0) given[key] = def[key];
      if (typeof given[key] === "object" && given[key] !== null) {
        this.mergeDefault(def[key], given[key]);
      }
    }
    return given;
  }
  isNumber(data) {
    return /^[+-]?\d+(\.\d+)?$/.test(data);
  }
  /** @ignore */
  on(event, listener) {
    super.on(event, (...args) => listener(...args));
    return this;
  }
  /** @ignore */
  once(event, listener) {
    super.once(event, (...args) => listener(...args));
    return this;
  }
  /** @ignore */
  off(event, listener) {
    super.off(event, (...args) => listener(...args));
    return this;
  }
  /** @ignore */
  emit(event, ...data) {
    return super.emit(event, ...data);
  }
};

// src/Plugin/RainlinkPlugin.ts
var RainlinkPlugin = class {
  constructor() {
    this.isRainlinkPlugin = true;
  }
  /** Name function for getting plugin name */
  name() {
    throw new Error("Plugin must implement name() and return a plguin name string");
  }
  /** Type function for diferent type of plugin */
  type() {
    throw new Error('Plugin must implement type() and return "sourceResolver" or "default"');
  }
  /** Load function for make the plugin working */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  load(manager) {
    throw new Error("Plugin must implement load()");
  }
  /** unload function for make the plugin stop working */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  unload(manager) {
    throw new Error("Plugin must implement unload()");
  }
};

// src/Plugin/SourceRainlinkPlugin.ts
var SourceRainlinkPlugin = class extends RainlinkPlugin {
  /**
    * sourceName function for source plugin register search engine.
    * This will make plugin avalible to search when set the source to default source
    * @returns string
    */
  sourceName() {
    throw new Error("Source plugin must implement sourceName() and return as string");
  }
  /**
    * sourceIdentify function for source plugin register search engine.
    * This will make plugin avalible to search when set the source to default source
    * @returns string
    */
  sourceIdentify() {
    throw new Error("Source plugin must implement sourceIdentify() and return as string");
  }
  /**
    * directSearchChecker function for checking if query have direct search param.
    * @returns boolean
    */
  directSearchChecker(query) {
    const directSearchRegex = /directSearch=(.*)/;
    const isDirectSearch = directSearchRegex.exec(query);
    return isDirectSearch == null;
  }
  /**
    * searchDirect function for source plugin search directly without fallback.
    * This will avoid overlaps in search function
    * @returns RainlinkSearchResult
    */
  searchDirect(query, options) {
    return __async(this, null, function* () {
      throw new Error("Source plugin must implement sourceIdentify() and return as string");
    });
  }
};

// src/index.ts
var version = metadata.version;
export {
  AbstractDecoder,
  AbstractDriver,
  AbstractLibrary,
  AllowedPackets,
  Lavalink3,
  Lavalink3loadType,
  Lavalink4,
  LavalinkDecoder,
  LavalinkLoadType,
  Library_default as Library,
  Nodelink2,
  Nodelink2loadType,
  Rainlink,
  RainlinkConnectState,
  RainlinkDatabase,
  RainlinkEvents,
  RainlinkFilter,
  RainlinkFilterData,
  RainlinkLoopMode,
  RainlinkNode,
  RainlinkNodeManager,
  RainlinkPlayer,
  RainlinkPlayerEvents,
  RainlinkPlayerManager,
  RainlinkPlayerState,
  RainlinkPlugin,
  RainlinkPluginType,
  RainlinkQueue,
  RainlinkRest,
  RainlinkSearchResultType,
  RainlinkTrack,
  RainlinkVoice,
  RainlinkWebsocket,
  RainlinkWebsocketState,
  SourceIDs,
  SourceRainlinkPlugin,
  VoiceConnectState,
  VoiceState,
  metadata,
  version
};
//# sourceMappingURL=index.mjs.map