import EventEmitter, { EventEmitter as EventEmitter$1 } from 'node:events';
import { Socket } from 'node:net';
import Websocket from 'ws';

/**
 * All rainlink manager events
 */
declare enum RainlinkEvents {
    Debug = "debug",
    NodeConnect = "nodeConnect",
    NodeDisconnect = "nodeDisconnect",
    NodeReconnect = "nodeReconnect",
    NodeClosed = "nodeClosed",
    NodeError = "nodeError",
    PlayerCreate = "playerCreate",
    PlayerDestroy = "playerDestroy",
    PlayerConnect = "playerConnect",
    PlayerDisconnect = "playerDisconnect",
    PlayerUpdate = "playerUpdate",
    PlayerMoved = "playerMoved",
    PlayerPause = "playerPause",
    PlayerResume = "playerResume",
    PlayerException = "playerException",
    PlayerWebsocketClosed = "playerWebsocketClosed",
    TrackStuck = "trackStuck",
    TrackStart = "trackStart",
    TrackEnd = "trackEnd",
    TrackResolveError = "trackResolveError",
    QueueAdd = "queueAdd",
    QueueRemove = "queueRemove",
    QueueShuffle = "queueShuffle",
    QueueClear = "queueClear",
    QueueEmpty = "queueEmpty"
}
/**
 * Rainlink node connect state
 */
declare enum RainlinkConnectState {
    Connected = 0,
    Disconnected = 1,
    Closed = 2
}
/**
 * Discord voice state
 */
declare enum VoiceState {
    SESSION_READY = 0,
    SESSION_ID_MISSING = 1,
    SESSION_ENDPOINT_MISSING = 2,
    SESSION_FAILED_UPDATE = 3
}
/**
 * Discord voice connect status state
 */
declare enum VoiceConnectState {
    CONNECTING = 0,
    NEARLY = 1,
    CONNECTED = 2,
    RECONNECTING = 3,
    DISCONNECTING = 4,
    DISCONNECTED = 5
}
/**
 * Lavalink load type enum
 */
declare enum LavalinkLoadType {
    TRACK = "track",
    PLAYLIST = "playlist",
    SEARCH = "search",
    EMPTY = "empty",
    ERROR = "error"
}
/**
 * Lavalink default source
 */
declare const SourceIDs: {
    name: string;
    id: string;
}[];
/**
 * Rainlink plugin type
 */
declare enum RainlinkPluginType {
    Default = "default",
    SourceResolver = "sourceResolver"
}
/**
 * Rainlink player connect state
 */
declare enum RainlinkPlayerState {
    CONNECTED = 0,
    DISCONNECTED = 1,
    DESTROYED = 2
}
/**
 * Rainlink loop enum
 */
declare enum RainlinkLoopMode {
    SONG = "song",
    QUEUE = "queue",
    NONE = "none"
}
/** @ignore */
declare const RainlinkFilterData: {
    clear: {};
    eightD: {
        rotation: {
            rotationHz: number;
        };
    };
    soft: {
        lowPass: {
            smoothing: number;
        };
    };
    speed: {
        timescale: {
            speed: number;
            pitch: number;
            rate: number;
        };
    };
    karaoke: {
        karaoke: {
            level: number;
            monoLevel: number;
            filterBand: number;
            filterWidth: number;
        };
    };
    nightcore: {
        timescale: {
            speed: number;
            pitch: number;
            rate: number;
        };
    };
    pop: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    vaporwave: {
        equalizer: {
            band: number;
            gain: number;
        }[];
        timescale: {
            pitch: number;
        };
        tremolo: {
            depth: number;
            frequency: number;
        };
    };
    bass: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    party: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    earrape: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    equalizer: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    electronic: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    radio: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    tremolo: {
        tremolo: {
            depth: number;
            frequency: number;
        };
    };
    treblebass: {
        equalizer: {
            band: number;
            gain: number;
        }[];
    };
    vibrato: {
        vibrato: {
            depth: number;
            frequency: number;
        };
    };
    china: {
        timescale: {
            speed: number;
            pitch: number;
            rate: number;
        };
    };
    chimpunk: {
        timescale: {
            speed: number;
            pitch: number;
            rate: number;
        };
    };
    darthvader: {
        timescale: {
            speed: number;
            pitch: number;
            rate: number;
        };
    };
    daycore: {
        equalizer: {
            band: number;
            gain: number;
        }[];
        timescale: {
            pitch: number;
            rate: number;
        };
    };
    doubletime: {
        timescale: {
            speed: number;
        };
    };
    pitch: {
        timescale: {
            pitch: number;
        };
    };
    rate: {
        timescale: {
            rate: number;
        };
    };
    slow: {
        timescale: {
            speed: number;
            pitch: number;
            rate: number;
        };
    };
};
type RainlinkFilterMode = keyof typeof RainlinkFilterData;

/**
 * The voice channel options interface for creating player
 */
interface VoiceChannelOptions {
    guildId: string;
    shardId: number;
    voiceId: string;
    textId: string;
    volume?: number;
    nodeName?: string;
    deaf?: boolean;
    mute?: boolean;
}
/**
 * The filter options interface for using with updatePlyer()
 */
interface FilterOptions {
    volume?: number;
    equalizer?: Band[];
    karaoke?: Karaoke | null;
    timescale?: Timescale | null;
    tremolo?: Freq | null;
    vibrato?: Freq | null;
    rotation?: Rotation | null;
    distortion?: Distortion | null;
    channelMix?: ChannelMix | null;
    lowPass?: LowPass | null;
}
interface Band {
    band: number;
    gain: number;
}
interface Karaoke {
    level?: number;
    monoLevel?: number;
    filterBand?: number;
    filterWidth?: number;
}
interface Timescale {
    speed?: number;
    pitch?: number;
    rate?: number;
}
interface Freq {
    frequency?: number;
    depth?: number;
}
interface Rotation {
    rotationHz?: number;
}
interface Distortion {
    sinOffset?: number;
    sinScale?: number;
    cosOffset?: number;
    cosScale?: number;
    tanOffset?: number;
    tanScale?: number;
    offset?: number;
    scale?: number;
}
interface ChannelMix {
    leftToLeft?: number;
    leftToRight?: number;
    rightToLeft?: number;
    rightToRight?: number;
}
interface LowPass {
    smoothing?: number;
}
interface PlayOptions {
    noReplace?: boolean;
    pause?: boolean;
    startTime?: number;
    endTime?: number;
    replaceCurrent?: boolean;
    position?: number;
}
interface PlayEncodedOptions {
    encoded: string;
    options?: {
        noReplace?: boolean;
        pause?: boolean;
        startTime?: number;
        endTime?: number;
        volume?: number;
    };
}

/**
 * Exception interface
 */
interface Exception {
    message: string;
    severity: Severity;
    cause: string;
}
/**
 * Exception severity interface
 */
type Severity = 'common' | 'suspicious' | 'fault';

/** The lavalink server status interface */
interface NodeStats {
    players: number;
    playingPlayers: number;
    memory: {
        reservable: number;
        used: number;
        free: number;
        allocated: number;
    };
    frameStats: {
        sent: number;
        deficit: number;
        nulled: number;
    };
    cpu: {
        cores: number;
        systemLoad: number;
        lavalinkLoad: number;
    };
    uptime: number;
}
/** The lavalink server status response interface */
interface LavalinkNodeStatsResponse {
    op: string;
    players: number;
    playingPlayers: number;
    memory: {
        reservable: number;
        used: number;
        free: number;
        allocated: number;
    };
    frameStats: {
        sent: number;
        deficit: number;
        nulled: number;
    };
    cpu: {
        cores: number;
        systemLoad: number;
        lavalinkLoad: number;
    };
    uptime: number;
}
/** The audio sending node infomation interface */
type NodeInfo = {
    version: NodeInfoVersion;
    buildTime: number;
    git: NodeInfoGit;
    jvm: string;
    lavaplayer: string;
    sourceManagers: string[];
    filters: string[];
    plugins: NodeInfoPlugin[];
};
/** The audio sending node version infomation interface */
type NodeInfoVersion = {
    semver: string;
    major: number;
    minor: number;
    patch: number;
    preRelease?: string;
    build?: string;
};
/** The audio sending node git infomation interface */
type NodeInfoGit = {
    branch: string;
    commit: string;
    commitTime: number;
};
/** The audio sending node plugin infomation interface */
type NodeInfoPlugin = {
    name: string;
    version: string;
};

interface RainlinkRequesterOptions extends RequestInit {
    params?: string | Record<string, string>;
    data?: Record<string, unknown>;
    path: string;
    rawReqData?: UpdatePlayerInfo;
}
type LavalinkStats = Omit<LavalinkNodeStatsResponse, 'op'>;
interface RawTrack {
    encoded: string;
    info: {
        identifier: string;
        isSeekable: boolean;
        author: string;
        length: number;
        isStream: boolean;
        position: number;
        title: string;
        uri: string | null;
        artworkUrl: string | null;
        isrc: string | null;
        sourceName: string;
    };
    pluginInfo: unknown;
}
interface LavalinkPlayerVoice {
    token: string;
    endpoint: string;
    sessionId: string;
    connected?: boolean;
    ping?: number;
}
interface LavalinkPlayerVoiceOptions extends Omit<LavalinkPlayerVoice, 'connected' | 'ping'> {
}
interface LavalinkPlayer {
    guildId: string;
    track?: RawTrack;
    volume: number;
    paused: boolean;
    voice: LavalinkPlayerVoice;
    filters: FilterOptions;
}
interface LavalinkPlayer {
    guildId: string;
    track?: RawTrack;
    volume: number;
    paused: boolean;
    voice: LavalinkPlayerVoice;
    filters: FilterOptions;
}
interface UpdatePlayerTrack {
    encoded?: string | null;
    identifier?: string;
    userData?: Record<string, any>;
    length?: number;
}
interface UpdatePlayerOptions {
    track?: UpdatePlayerTrack;
    identifier?: string;
    position?: number;
    endTime?: number;
    volume?: number;
    paused?: boolean;
    filters?: FilterOptions;
    voice?: LavalinkPlayerVoiceOptions;
}
interface UpdatePlayerInfo {
    guildId: string;
    playerOptions: UpdatePlayerOptions;
    noReplace?: boolean;
}
interface TrackResult {
    loadType: LavalinkLoadType.TRACK;
    data: RawTrack;
}
interface PlaylistResult {
    loadType: LavalinkLoadType.PLAYLIST;
    data: Playlist;
}
interface SearchResult {
    loadType: LavalinkLoadType.SEARCH;
    data: RawTrack[];
}
interface EmptyResult {
    loadType: LavalinkLoadType.EMPTY;
    data: Record<string, never>;
}
interface ErrorResult {
    loadType: LavalinkLoadType.ERROR;
    data: Exception;
}
interface Playlist {
    encoded: string;
    info: {
        name: string;
        selectedTrack: number;
    };
    pluginInfo: unknown;
    tracks: RawTrack[];
}
type LavalinkResponse = TrackResult | PlaylistResult | SearchResult | EmptyResult | ErrorResult;
interface RoutePlanner {
    class: null | 'RotatingIpRoutePlanner' | 'NanoIpRoutePlanner' | 'RotatingNanoIpRoutePlanner' | 'BalancingIpRoutePlanner';
    details: null | {
        ipBlock: {
            type: string;
            size: string;
        };
        failingAddresses: Address[];
        rotateIndex: string;
        ipIndex: string;
        currentAddress: string;
        blockIndex: string;
        currentAddressIndex: string;
    };
}
interface Address {
    address: string;
    failingTimestamp: number;
    failingTime: string;
}

/**
 * The rest class for get and calling
 * from audio sending node/server REST API
 */
declare class RainlinkRest {
    /** The rainlink manager */
    manager: Rainlink;
    protected options: RainlinkNodeOptions;
    /** The node manager (RainlinkNode class) */
    nodeManager: RainlinkNode;
    protected sessionId: string | null;
    /**
   * The lavalink rest server handler class
   * @param manager The rainlink manager
   * @param options The rainlink node options, from RainlinkNodeOptions interface
   * @param nodeManager The rainlink's lavalink server handler class
   */
    constructor(manager: Rainlink, options: RainlinkNodeOptions, nodeManager: RainlinkNode);
    /**
   * Gets all the player with the specified sessionId
   * @returns Promise that resolves to an array of Lavalink players
   */
    getPlayers(): Promise<LavalinkPlayer[]>;
    /**
   * Gets current lavalink status
   * @returns Promise that resolves to an object of current lavalink status
   */
    getStatus(): Promise<LavalinkStats | undefined>;
    /**
   * Decode a single track from "encoded" properties
   * @returns Promise that resolves to an object of raw track
   */
    decodeTrack(base64track: string): Promise<RawTrack | undefined>;
    /**
   * Updates a Lavalink player
   * @returns Promise that resolves to a Lavalink player
   */
    updatePlayer(data: UpdatePlayerInfo): Promise<void>;
    /**
   * Destroy a Lavalink player
   * @returns Promise that resolves to a Lavalink player
   */
    destroyPlayer(guildId: string): Promise<void>;
    /**
   * A track resolver function to get track from lavalink
   * @returns LavalinkResponse
   */
    resolver(data: string): Promise<LavalinkResponse | undefined>;
    /**
   * Get routeplanner status from Lavalink
   * @returns Promise that resolves to a routeplanner response
   */
    getRoutePlannerStatus(): Promise<RoutePlanner | undefined>;
    /**
   * Release blacklisted IP address into pool of IPs
   * @param address IP address
   */
    unmarkFailedAddress(address: string): Promise<void>;
    /**
   * Get Lavalink info
   */
    getInfo(): Promise<NodeInfo | undefined>;
    protected testJSON(text: string): boolean;
}

declare class RainlinkPlayerEvents {
    protected readonly methods: Record<string, (manager: Rainlink, data: Record<string, any>) => void>;
    constructor();
    initial(data: Record<string, any>, manager: Rainlink): void;
    protected TrackStartEvent(manager: Rainlink, data: Record<string, any>): void;
    protected TrackEndEvent(manager: Rainlink, data: Record<string, any>): boolean | Promise<RainlinkPlayer> | undefined;
    protected TrackExceptionEvent(manager: Rainlink, data: Record<string, any>): void;
    protected TrackStuckEvent(manager: Rainlink, data: Record<string, any>): void;
    protected WebSocketClosedEvent(manager: Rainlink, data: Record<string, any>): void;
    protected PlayerUpdate(manager: Rainlink, data: Record<string, any>): void;
}

type ContinueInfoType = {
    type: number;
    buffer: Buffer[];
};
type RainlinkWebsocketOptions = {
    timeout?: number;
    headers?: Record<string, string | number>;
    legacy?: boolean;
};
type RainlinkWebsocketFHInfo = {
    opcode: number;
    fin: boolean;
    payloadLength: number;
    mask: Buffer | null;
    startIndex: number;
};
declare enum RainlinkWebsocketState {
    WAITING = "WAITING",
    PROCESSING = "PROCESSING"
}
interface RWSEvents {
    message: [data: string, isBin: boolean];
    close: [code: number, reason: Buffer | string];
    error: [err: Error];
    open: [];
    pong: [];
}
/** Modded version of PWSL */
declare class RainlinkWebsocket extends EventEmitter {
    protected url: string;
    protected options: RainlinkWebsocketOptions;
    protected socket: Socket | null;
    protected continueInfo: ContinueInfoType;
    protected state: RainlinkWebsocketState;
    protected legacyWs?: Websocket;
    /**
   * @param url The WS url have to connect
   * @param options Some additional options of PWSL
   */
    constructor(url: string, options: RainlinkWebsocketOptions);
    /**
   * Connect to current websocket link
   */
    connect(): void;
    /**
   * Clean up all current websocket state
   * @returns boolean
   */
    cleanup(): boolean | 'legacy-is-running';
    /**
   * Send raw buffer data to ws server
   * @returns boolean
   */
    sendData(data: Buffer, options: {
        len: number;
        fin?: boolean;
        opcode: number;
        mask?: Buffer | boolean;
    }): boolean;
    /**
   * Send string data to ws server
   * @returns boolean
   */
    send(data: string): boolean;
    /**
   * Close the connection of tthe current ws server
   * @returns boolean
   */
    close(code?: number, reason?: string): boolean;
    /** @ignore */
    on<K extends keyof RWSEvents>(event: K, listener: (...args: RWSEvents[K]) => void): this;
    /** @ignore */
    once<K extends keyof RWSEvents>(event: K, listener: (...args: RWSEvents[K]) => void): this;
    /** @ignore */
    off<K extends keyof RWSEvents>(event: K, listener: (...args: RWSEvents[K]) => void): this;
    /** @ignore */
    emit<K extends keyof RWSEvents>(event: K, ...data: RWSEvents[K]): boolean;
    protected bun(): Promise<void>;
    protected checkData(): Promise<void>;
    protected parseFrameHeaderInfo(buffer: Buffer): {
        opcode: number;
        fin: boolean;
        payloadLength: number;
        mask: Buffer | null;
        startIndex: number;
    };
    protected parseFrameHeader(info: RainlinkWebsocketFHInfo, buffer: Buffer): {
        opcode: number;
        fin: boolean;
        buffer: Buffer;
        payloadLength: number;
        rest: Buffer;
    };
    protected processData(data: Buffer): Promise<void>;
}

/**
 * A class for storing data using key like Map.
 * Aka: reduce version of Map
 */
declare class RainlinkDatabase<G = unknown> {
    protected cache: Record<string, G>;
    /**
   * Get data from database
   * @param key key of that data
   * @returns D
   */
    get<D = G>(key: string): D | undefined;
    /**
   * detete data from database and returns the deleted data
   * @param key key of that data
   * @returns D
   */
    delete<D = G>(key: string): D | undefined;
    /**
   * detete all data from database
   */
    clear(): void;
    /**
   * Set data from database
   * @param key the key you want to set
   * @param data data of that key
   * @returns D
   */
    set<D = G>(key: string, data: D): D | undefined;
    /**
   * executes a provided function once for each array element.
   * @param callback Callback function
   */
    forEach(callback: (value: G, key: string) => unknown): void;
    /**
   * Get how many elements of current database
   * @returns number
   */
    get size(): number;
    /**
   * Get all current values of current database
   * @returns unknown[]
   */
    get values(): G[];
    /**
   * Get all current values of current database
   * @returns unknown[]
   */
    get full(): [string, G][];
}

declare class RainlinkFunctions extends RainlinkDatabase<(...args: any) => unknown> {
    /**
   * Function to execute custom function
   * @param commandName Function name
   * @param args Function args
   */
    exec<D = unknown>(commandName: string, ...args: unknown[]): Promise<D | undefined>;
}

/**
 * The abstract class for developing driver
 * to use another audio sending server.
 */
declare abstract class AbstractDriver {
    /**  The id for the driver*/
    abstract id: string;
    /** Ws url for dealing connection to lavalink/nodelink server */
    abstract wsUrl: string;
    /** Http url for dealing rest request to lavalink/nodelink server */
    abstract httpUrl: string;
    /** The lavalink server season id to resume */
    abstract sessionId: string | null;
    /** All function to extend support driver on RainlinkPlayer class */
    abstract playerFunctions: RainlinkFunctions;
    /** All function to extend support driver on Rainlink class */
    abstract functions: RainlinkFunctions;
    /** Rainlink manager class */
    abstract manager: Rainlink;
    /** Rainlink reuqested lavalink/nodelink server */
    abstract node: RainlinkNode;
    /**
     * Connect to lavalink/nodelink server
     * @returns WebSocket
     */
    abstract connect(): RainlinkWebsocket;
    /**
     * Fetch function for dealing rest request to lavalink/nodelink server
     * @returns Promise<D | undefined>
     */
    abstract requester<D = any>(options: RainlinkRequesterOptions): Promise<D | undefined>;
    /**
     * Close the lavalink/nodelink server
     * @returns void
     */
    abstract wsClose(): void;
    /**
     * Update a season to resume able or not
     * @returns void
     */
    abstract updateSession(sessionId: string, mode: boolean, timeout: number): Promise<void>;
}

/** The node manager class for managing current audio sending server/node */
declare class RainlinkNode {
    /** The rainlink manager */
    manager: Rainlink;
    /** The rainlink node options */
    options: RainlinkNodeOptions;
    /** The rainlink rest manager */
    rest: RainlinkRest;
    /** The lavalink server online status */
    online: boolean;
    protected retryCounter: number;
    /** The lavalink server connect state */
    state: RainlinkConnectState;
    /** The lavalink server all status */
    stats: NodeStats;
    protected sudoDisconnect: boolean;
    protected wsEvent: RainlinkPlayerEvents;
    /** Driver for connect to current version of Nodelink/Lavalink */
    driver: AbstractDriver;
    /**
   * The lavalink server handler class
   * @param manager The rainlink manager
   * @param options The lavalink server options
   */
    constructor(manager: Rainlink, options: RainlinkNodeOptions);
    /** Connect this lavalink server */
    connect(): RainlinkWebsocket;
    /** @ignore */
    wsOpenEvent(): void;
    /** @ignore */
    wsMessageEvent(data: Record<string, any>): void;
    /** @ignore */
    wsErrorEvent(logs: Error): void;
    /** @ignore */
    wsCloseEvent(code: number, reason: Buffer | string): Promise<void>;
    protected nodeClosed(): void;
    protected updateStatusData(data: LavalinkNodeStatsResponse): NodeStats;
    /** Disconnect this lavalink server */
    disconnect(): void;
    /** Reconnect back to this lavalink server */
    reconnect(noClean: boolean): void;
    /** Clean all the lavalink server state and set to default value */
    clean(online?: boolean): void;
    protected debug(logs: string): void;
}

interface ResolveOptions {
    /** Whenever u want to overwrite the track or not */
    overwrite?: boolean;
    /** Rainlink player property */
    player?: RainlinkPlayer;
}

/**
 * A class for managing track info
 */
declare class RainlinkTrack {
    protected options: RawTrack;
    /** Encoded string from lavalink */
    encoded: string;
    /** Identifier string from lavalink */
    identifier: string;
    /** Whenever track is seekable or not */
    isSeekable: boolean;
    /** Track's author */
    author: string;
    /** Track's duration */
    duration: number;
    /** Whenever track is stream able or not */
    isStream: boolean;
    /** Track's position */
    position: number;
    /** Track's title */
    title: string;
    /** Track's URL */
    uri: string | null;
    /** Track's artwork URL */
    artworkUrl: string | null;
    /** Track's isrc */
    isrc: string | null;
    /** Track's source name */
    source: string;
    /** Data from lavalink plugin */
    pluginInfo: unknown;
    /** Track's requester */
    requester: unknown;
    /** Track's realUri (youtube fall back) */
    realUri: string | null;
    /** Name of the driver that search this track */
    driverName?: string;
    /**
   * The rainlink track class for playing track from lavalink
   * @param options The raw track resolved from rest, use RawTrack interface
   * @param requester The requester details of this track
   */
    constructor(options: RawTrack, requester: unknown, driverName?: string);
    /**
   * Whenever track is able to play or not
   * @returns boolean
   */
    get isPlayable(): boolean;
    /**
   * Get all raw details of the track
   * @returns RawTrack
   */
    get raw(): RawTrack;
    /** @ignore */
    resolver(player: RainlinkPlayer, options?: ResolveOptions): Promise<RainlinkTrack>;
    protected getTrack(player: RainlinkPlayer): Promise<RawTrack>;
    protected escapeRegExp(string: string): string;
    protected resolverEngine(player: RainlinkPlayer): Promise<RainlinkSearchResult>;
}

/**
 * A class for managing track queue
 */
declare class RainlinkQueue extends Array<RainlinkTrack> {
    /** Rainlink manager */
    manager: Rainlink;
    /** Rainlink player */
    player: RainlinkPlayer;
    /**
   * The rainlink track queue handler class
   * @param manager The rainlink manager
   * @param player The current rainlink player
   */
    constructor(manager: Rainlink, player: RainlinkPlayer);
    /** Get the size of queue */
    get size(): number;
    /** Get the size of queue including current */
    get totalSize(): number;
    /** Check if the queue is empty or not */
    get isEmpty(): boolean;
    /** Get the queue's duration */
    get duration(): number;
    /** Current playing track */
    current: RainlinkTrack | undefined | null;
    /** Previous playing tracks */
    previous: RainlinkTrack[];
    /**
   * Add track(s) to the queue
   * @param track RainlinkTrack to add
   * @returns RainlinkQueue
   */
    add(track: RainlinkTrack | RainlinkTrack[]): RainlinkQueue;
    /**
   * Remove track from the queue
   * @param position Position of the track
   * @returns RainlinkQueue
   */
    remove(position: number): RainlinkQueue;
    /** Shuffle the queue */
    shuffle(): RainlinkQueue;
    /** Clear the queue */
    clear(): RainlinkQueue;
}

/**
 * This class is for set, clear and managing filter
 */
declare class RainlinkFilter {
    protected player: RainlinkPlayer;
    /**
   * Current filter config
   */
    currentFilter: FilterOptions | null;
    constructor(player: RainlinkPlayer);
    /**
   * Set a filter that prebuilt in rainlink
   * @param filter The filter name
   * @returns RainlinkPlayer
   */
    set(filter: RainlinkFilterMode): Promise<RainlinkPlayer>;
    /**
   * Clear all the filter
   * @returns RainlinkPlayer
   */
    clear(): Promise<RainlinkPlayer>;
    /**
   * Sets the filter volume of the player
   * @param volume Target volume 0.0-5.0
   */
    setVolume(volume: number): Promise<RainlinkPlayer>;
    /**
   * Change the equalizer settings applied to the currently playing track
   * @param equalizer An array of objects that conforms to the Bands type that define volumes at different frequencies
   */
    setEqualizer(equalizer: Band[]): Promise<RainlinkPlayer>;
    /**
   * Change the karaoke settings applied to the currently playing track
   * @param karaoke An object that conforms to the KaraokeSettings type that defines a range of frequencies to mute
   */
    setKaraoke(karaoke?: Karaoke): Promise<RainlinkPlayer>;
    /**
   * Change the timescale settings applied to the currently playing track
   * @param timescale An object that conforms to the TimescaleSettings type that defines the time signature to play the audio at
   */
    setTimescale(timescale?: Timescale): Promise<RainlinkPlayer>;
    /**
   * Change the tremolo settings applied to the currently playing track
   * @param tremolo An object that conforms to the FreqSettings type that defines an oscillation in volume
   */
    setTremolo(tremolo?: Freq): Promise<RainlinkPlayer>;
    /**
   * Change the vibrato settings applied to the currently playing track
   * @param vibrato An object that conforms to the FreqSettings type that defines an oscillation in pitch
   */
    setVibrato(vibrato?: Freq): Promise<RainlinkPlayer>;
    /**
   * Change the rotation settings applied to the currently playing track
   * @param rotation An object that conforms to the RotationSettings type that defines the frequency of audio rotating round the listener
   */
    setRotation(rotation?: Rotation): Promise<RainlinkPlayer>;
    /**
   * Change the distortion settings applied to the currently playing track
   * @param distortion An object that conforms to DistortionSettings that defines distortions in the audio
   * @returns The current player instance
   */
    setDistortion(distortion?: Distortion): Promise<RainlinkPlayer>;
    /**
   * Change the channel mix settings applied to the currently playing track
   * @param channelMix An object that conforms to ChannelMixSettings that defines how much the left and right channels affect each other (setting all factors to 0.5 causes both channels to get the same audio)
   */
    setChannelMix(channelMix?: ChannelMix): Promise<RainlinkPlayer>;
    /**
   * Change the low pass settings applied to the currently playing track
   * @param lowPass An object that conforms to LowPassSettings that defines the amount of suppression on higher frequencies
   */
    setLowPass(lowPass?: LowPass): Promise<RainlinkPlayer>;
    /**
   * Set a custom filter
   * @param filter The filter name
   * @returns RainlinkPlayer
   */
    setRaw(filter: FilterOptions): Promise<RainlinkPlayer>;
    protected debug(logs: string): void;
    protected checkDestroyed(): void;
}

/**
 * Represents the payload from a serverUpdate event
 */
interface ServerUpdate {
    token: string;
    guild_id: string;
    endpoint: string;
}
/**
 * Represents the partial payload from a stateUpdate event
 */
interface StateUpdatePartial {
    channel_id?: string;
    session_id?: string;
    self_deaf: boolean;
    self_mute: boolean;
}

declare class RainlinkVoice extends EventEmitter$1 {
    /**
   * Main manager class
   */
    manager: Rainlink;
    /**
   * Player's guild id
   */
    guildId: string;
    /**
   * Player's voice id
   */
    voiceId: string | null;
    /**
   * Connection state
   */
    state: VoiceConnectState;
    /**
   * Whether the player is deafened or not
   */
    deaf: boolean;
    /**
   * Whether the player is muted or not
   */
    mute: boolean;
    /**
   * ID of the Shard that contains the guild that contains the connected voice channel
   */
    shardId: number;
    /**
   * ID of the last voiceId connected to
   */
    lastvoiceId: string | null;
    /**
   * Region of connected voice channel
   */
    region: string | null;
    /**
   * Last region of the connected voice channel
   */
    lastRegion: string | null;
    /**
   * Cached serverUpdate event from Lavalink
   */
    serverUpdate: ServerUpdate | null;
    /**
   * ID of current session
   */
    sessionId: string | null;
    /**
   * Voice Options
   */
    options: VoiceChannelOptions;
    /**
   * Rainlink voice handler class
   * @param manager Rainlink manager
   * @param voiceOptions
   */
    constructor(manager: Rainlink, voiceOptions: VoiceChannelOptions);
    /**
   * Connect from the voice channel
   * @returns RainlinkPlayer
   */
    connect(): Promise<RainlinkVoice>;
    /**
   * Send voice data to discord
   * @internal
   */
    sendVoiceUpdate(): void;
    /**
   * Send data to Discord
   * @param data The data to send
   * @internal
   */
    sendDiscord(data: any): void;
    /**
   * Sets the server update data for this connection
   * @internal
   */
    setServerUpdate(data: ServerUpdate): void;
    /**
   * Update Session ID, Channel ID, Deafen status and Mute status of this instance
   * @internal
   */
    setStateUpdate({ session_id, channel_id, self_deaf, self_mute, }: StateUpdatePartial): void;
    /**
   * Disconnect from the voice channel
   * @returns RainlinkPlayer
   */
    disconnect(): void;
    protected debugDiscord(logs: string): void;
}

/**
 * A class for managing player action.
 */
declare class RainlinkPlayer {
    /**
   * Main manager class
   */
    manager: Rainlink;
    /**
   * Player's current using lavalink server
   */
    node: RainlinkNode;
    /**
   * Player's guild id
   */
    guildId: string;
    /**
   * Player's voice id
   */
    voiceId: string | null;
    /**
   * Player's text id
   */
    textId: string;
    /**
   * Player's queue
   */
    readonly queue: RainlinkQueue;
    /**
   * The temporary database of player, u can set any thing here and us like Map class!
   */
    readonly data: RainlinkDatabase<unknown>;
    /**
   * Whether the player is paused or not
   */
    paused: boolean;
    /**
   * Get the current track's position of the player
   */
    position: number;
    /**
   * Get the current volume of the player
   */
    volume: number;
    /**
   * Whether the player is playing or not
   */
    playing: boolean;
    /**
   * Get the current loop mode of the player
   */
    loop: RainlinkLoopMode;
    /**
   * Get the current state of the player
   */
    state: RainlinkPlayerState;
    /**
   * Whether the player is deafened or not
   */
    deaf: boolean;
    /**
   * Whether the player is muted or not
   */
    mute: boolean;
    /**
   * ID of the current track
   */
    track: string | null;
    /**
   * All function to extend support driver
   */
    functions: RainlinkFunctions;
    /**
   * ID of the Shard that contains the guild that contains the connected voice channel
   */
    shardId: number;
    /**
   * Filter class to set, clear get the current filter data
   */
    filter: RainlinkFilter;
    /**
   * Voice handler class
   */
    voice: RainlinkVoice;
    /** @ignore */
    sudoDestroy: boolean;
    /**
   * The rainlink player handler class
   * @param manager The rainlink manager
   * @param voiceOptions The rainlink voice option, use VoiceChannelOptions interface
   * @param node The rainlink current use node
   */
    constructor(manager: Rainlink, voice: RainlinkVoice, node: RainlinkNode);
    /**
   * Sends server update to lavalink
   * @internal
   */
    sendServerUpdate(): Promise<void>;
    /**
   * Destroy the player
   * @internal
   */
    destroy(): Promise<void>;
    /**
   * Play a track
   * @param track Track to play
   * @param options Play options
   * @returns RainlinkPlayer
   */
    play(track?: RainlinkTrack, options?: PlayOptions): Promise<RainlinkPlayer>;
    /**
   * Set the loop mode of the track
   * @param mode Mode to loop
   * @returns RainlinkPlayer
   */
    setLoop(mode: RainlinkLoopMode): RainlinkPlayer;
    /**
   * Search track directly from player
   * @param query The track search query link
   * @param options The track search options
   * @returns RainlinkSearchResult
   */
    search(query: string, options?: RainlinkSearchOptions): Promise<RainlinkSearchResult>;
    /**
   * Pause the track
   * @returns RainlinkPlayer
   */
    pause(): Promise<RainlinkPlayer>;
    /**
   * Resume the track
   * @returns RainlinkPlayer
   */
    resume(): Promise<RainlinkPlayer>;
    /**
   * Pause or resume a track but different method
   * @param mode Whether to pause or not
   * @returns RainlinkPlayer
   */
    setPause(mode: boolean): Promise<RainlinkPlayer>;
    /**
   * Play the previous track
   * @returns RainlinkPlayer
   */
    previous(): Promise<RainlinkPlayer>;
    /**
   * Get all previous track
   * @returns RainlinkTrack[]
   */
    getPrevious(): RainlinkTrack[];
    /**
   * Skip the current track
   * @returns RainlinkPlayer
   */
    skip(): Promise<RainlinkPlayer>;
    /**
   * Seek to another position in track
   * @param position Position to seek
   * @returns RainlinkPlayer
   */
    seek(position: number): Promise<RainlinkPlayer>;
    /**
   * Set another volume in player
   * @param volume Volume to cange
   * @returns RainlinkPlayer
   */
    setVolume(volume: number): Promise<RainlinkPlayer>;
    /**
   * Set player to mute or unmute
   * @param enable Enable or not
   * @returns RainlinkPlayer
   */
    setMute(enable: boolean): RainlinkPlayer;
    /**
   * Stop all avtivities and reset to default
   * @param destroy Whenever you want to destroy a player or not
   * @returns RainlinkPlayer
   */
    stop(destroy: boolean): Promise<RainlinkPlayer>;
    /**
   * Reset all data to default
   * @param emitEmpty Whenever emit empty event or not
   */
    clear(emitEmpty: boolean): void;
    /**
   * Set player to deaf or undeaf
   * @param enable Enable or not
   * @returns RainlinkPlayer
   */
    setDeaf(enable: boolean): RainlinkPlayer;
    /**
   * Disconnect from the voice channel
   * @returns RainlinkPlayer
   */
    disconnect(): RainlinkPlayer;
    /**
   * Set text channel
   * @param textId Text channel ID
   * @returns RainlinkPlayer
   */
    setTextChannel(textId: string): RainlinkPlayer;
    /**
   * Set voice channel and move the player to the voice channel
   * @param voiceId Voice channel ID
   * @returns RainlinkPlayer
   */
    setVoiceChannel(voiceId: string): RainlinkPlayer;
    /**
   * Send custom player update data to lavalink server
   * @param data Data to change
   * @returns RainlinkPlayer
   */
    send(data: UpdatePlayerInfo): Promise<RainlinkPlayer>;
    protected debug(logs: string): void;
    protected checkDestroyed(): void;
    protected debugDiscord(logs: string): void;
}

/** The node manager class for managing all active players */
declare class RainlinkPlayerManager extends RainlinkDatabase<RainlinkPlayer> {
    /** The rainlink manager */
    manager: Rainlink;
    /**
   * The main class for handling lavalink players
   * @param manager The rainlink manager
   */
    constructor(manager: Rainlink);
    /**
   * Create a player
   * @returns RainlinkPlayer
   * @internal
   */
    create(options: VoiceChannelOptions): Promise<RainlinkPlayer>;
    /**
   * Destroy a player
   * @returns The destroyed / disconnected player or undefined if none
   * @internal
   */
    destroy(guildId?: string): Promise<void>;
    protected debug(logs: string): void;
}

/** The node manager class for managing all audio sending server/node */
declare class RainlinkNodeManager extends RainlinkDatabase<RainlinkNode> {
    /** The rainlink manager */
    manager: Rainlink;
    /**
   * The main class for handling lavalink servers
   * @param manager
   */
    constructor(manager: Rainlink);
    /**
   * Add a new Node.
   * @returns RainlinkNode
   */
    add(node: RainlinkNodeOptions): RainlinkNode;
    /**
   * Get a least used node.
   * @returns RainlinkNode
   */
    getLeastUsed(customNodeArray?: RainlinkNode[]): Promise<RainlinkNode>;
    /**
   * Get all current nodes
   * @returns RainlinkNode[]
   */
    all(): RainlinkNode[];
    /**
   * Remove a node.
   * @returns void
   */
    remove(name: string): void;
    protected debug(logs: string): void;
}

/** The interface class for track resolver plugin, extend it to use */
declare class SourceRainlinkPlugin extends RainlinkPlugin {
    /**
   * sourceName function for source plugin register search engine.
   * This will make plugin avalible to search when set the source to default source
   * @returns string
   */
    sourceName(): string;
    /**
   * sourceIdentify function for source plugin register search engine.
   * This will make plugin avalible to search when set the source to default source
   * @returns string
   */
    sourceIdentify(): string;
    /**
   * directSearchChecker function for checking if query have direct search param.
   * @returns boolean
   */
    directSearchChecker(query: string): boolean;
    /**
   * searchDirect function for source plugin search directly without fallback.
   * This will avoid overlaps in search function
   * @returns RainlinkSearchResult
   */
    searchDirect(query: string, options?: RainlinkSearchOptions): Promise<RainlinkSearchResult>;
}

interface RainlinkEventsInterface {
    /**
     * Emitted when rainlink have a debug log.
     * @event Rainlink#debug
     */
    debug: [logs: string];
    /**
     * Emitted when a lavalink server is connected.
     * @event Rainlink#nodeConnect
     */
    nodeConnect: [node: RainlinkNode];
    /**
     * Emitted when a lavalink server is disconnected.
     * @event Rainlink#nodeDisconnect
     */
    nodeDisconnect: [node: RainlinkNode, code: number, reason: Buffer | string];
    /**
     * Emitted when a lavalink server is trying to reconnect.
     * @event Rainlink#nodeReconnect
     */
    nodeReconnect: [node: RainlinkNode];
    /**
     * Emitted when a lavalink server is closed.
     * @event Rainlink#nodeClosed
     */
    nodeClosed: [node: RainlinkNode];
    /**
     * Emitted when a lavalink server is errored.
     * @event Rainlink#nodeError
     */
    nodeError: [node: RainlinkNode, error: Error];
    /**
     * Emitted when a player is created.
     * @event Rainlink#playerCreate
     */
    playerCreate: [player: RainlinkPlayer];
    /**
     * Emitted when a player is going to destroyed.
     * @event Rainlink#playerDestroy
     */
    playerDestroy: [player: RainlinkPlayer];
    /**
     * Emitted when a player have an exception.
     * @event Rainlink#playerException
     */
    playerException: [player: RainlinkPlayer, data: Record<string, any>];
    /**
     * Emitted when a player updated info.
     * @event Rainlink#playerUpdate
     */
    playerUpdate: [player: RainlinkPlayer, data: Record<string, any>];
    /**
     * Emitted when a track paused.
     * @event Rainlink#playerPause
     */
    playerPause: [player: RainlinkPlayer, track: RainlinkTrack];
    /**
     * Emitted when a track resumed.
     * @event Rainlink#playerResume
     */
    playerResume: [player: RainlinkPlayer, data: RainlinkTrack];
    /**
     * Emitted when a player's websocket closed.
     * @event Rainlink#playerWebsocketClosed
     */
    playerWebsocketClosed: [player: RainlinkPlayer, data: Record<string, any>];
    /**
     * Emitted when a track is going to play.
     * @event Rainlink#trackStart
     */
    trackStart: [player: RainlinkPlayer, track: RainlinkTrack];
    /**
     * Emitted when a track is going to end.
     * @event Rainlink#trackEnd
     */
    trackEnd: [player: RainlinkPlayer, track: RainlinkTrack];
    /**
     * Emitted when a track stucked.
     * @event Rainlink#trackStuck
     */
    trackStuck: [player: RainlinkPlayer, data: Record<string, any>];
    /**
     * Emitted when a track is failed to resolve using fallback search engine.
     * @event Rainlink#trackResolveError
     */
    trackResolveError: [player: RainlinkPlayer, track: RainlinkTrack, message: string];
    /**
     * Emitted when a track added into queue.
     * @event Rainlink#queueAdd
     */
    queueAdd: [player: RainlinkPlayer, queue: RainlinkQueue, track: RainlinkTrack[]];
    /**
     * Emitted when a track removed from queue.
     * @event Rainlink#queueRemove
     */
    queueRemove: [player: RainlinkPlayer, queue: RainlinkQueue, track: RainlinkTrack];
    /**
     * Emitted when a queue shuffled.
     * @event Rainlink#queueShuffle
     */
    queueShuffle: [player: RainlinkPlayer, queue: RainlinkQueue];
    /**
     * Emitted when a queue cleared.
     * @event Rainlink#queueClear
     */
    queueClear: [player: RainlinkPlayer, queue: RainlinkQueue];
    /**
     * Emitted when a queue is empty.
     * @event Rainlink#queueEmpty
     */
    queueEmpty: [player: RainlinkPlayer, queue: RainlinkQueue];
}

/** The heart of Rainlink. Manage all package action */
declare class Rainlink extends EventEmitter$1 {
    /**
   * Discord library connector
   */
    readonly library: AbstractLibrary;
    /**
   * Lavalink server that has been configured
   */
    nodes: RainlinkNodeManager;
    /**
   * Rainlink options
   */
    rainlinkOptions: RainlinkOptions;
    /**
   * Bot id
   */
    id: string | undefined;
    /**
   * Player maps
   */
    players: RainlinkPlayerManager;
    /**
   * All search engine
   */
    searchEngines: RainlinkDatabase<string>;
    /**
   * All search plugins (resolver plugins)
   */
    searchPlugins: RainlinkDatabase<SourceRainlinkPlugin>;
    /**
   * All plugins (include resolver plugins)
   */
    plugins: RainlinkDatabase<RainlinkPlugin>;
    /**
   * The rainlink manager
   */
    drivers: Constructor<AbstractDriver>[];
    /**
   * The current bott's shard count
   */
    shardCount: number;
    /**
   * All voice handler currently
   */
    voices: RainlinkDatabase<RainlinkVoice>;
    /**
   * The main class that handle all works in lavalink server.
   * Call this class by using new Rainlink(your_params) to use!
   * @param options The main ranlink options
   */
    constructor(options: RainlinkOptions);
    protected initialSearchEngines(): void;
    /**
   * Create a new player.
   * @returns RainlinkNode
   */
    create(options: VoiceChannelOptions): Promise<RainlinkPlayer>;
    /**
   * Destroy a specific player.
   * @returns void
   */
    destroy(guildId: string): Promise<void>;
    /**
   * Search a specific track.
   * @returns RainlinkSearchResult
   */
    search(query: string, options?: RainlinkSearchOptions): Promise<RainlinkSearchResult>;
    protected buildSearch(playlistName?: string, tracks?: RainlinkTrack[], type?: RainlinkSearchResultType): RainlinkSearchResult;
    protected get defaultOptions(): RainlinkAdditionalOptions;
    protected mergeDefault<T extends {
        [key: string]: any;
    }>(def: T, given: T): Required<T>;
    protected isNumber(data: string): boolean;
    /** @ignore */
    on<K extends keyof RainlinkEventsInterface>(event: K, listener: (...args: RainlinkEventsInterface[K]) => void): this;
    /** @ignore */
    once<K extends keyof RainlinkEventsInterface>(event: K, listener: (...args: RainlinkEventsInterface[K]) => void): this;
    /** @ignore */
    off<K extends keyof RainlinkEventsInterface>(event: K, listener: (...args: RainlinkEventsInterface[K]) => void): this;
    /** @ignore */
    emit<K extends keyof RainlinkEventsInterface>(event: K, ...data: RainlinkEventsInterface[K]): boolean;
}

/** The interface class for another rainlink plugin, extend it to use */
declare class RainlinkPlugin {
    readonly isRainlinkPlugin: boolean;
    /** Name function for getting plugin name */
    name(): string;
    /** Type function for diferent type of plugin */
    type(): RainlinkPluginType;
    /** Load function for make the plugin working */
    load(manager: Rainlink): void;
    /** unload function for make the plugin stop working */
    unload(manager: Rainlink): void;
}

/**
 * A structure interface
 */
type Constructor<T> = new (...args: any[]) => T;
/**
 * The structures options interface for custom class/structures
 */
interface Structures {
    /**
     * A custom structure that extends the RainlinkRest class
     */
    rest?: Constructor<RainlinkRest>;
    /**
     * A custom structure that extends the RainlinkPlayer class
     */
    player?: Constructor<RainlinkPlayer>;
    /**
     * A custom structure that extends the RainlinkQueue class
     */
    queue?: Constructor<RainlinkQueue>;
    /**
     * A custom structure that extends the RainlinkQueue class
     */
    filter?: Constructor<RainlinkFilter>;
}
/**
 * Rainlink node option interface
 */
interface RainlinkNodeOptions {
    /** Name for get the lavalink server info in rainlink */
    name: string;
    /** The ip address or domain of lavalink server */
    host: string;
    /** The port that lavalink server exposed */
    port: number;
    /** The password of lavalink server */
    auth: string;
    /** Whenever lavalink user ssl or not */
    secure: boolean;
    /** The driver class for handling lavalink response */
    driver?: string;
    /** Use legacy ws client (Require install [ws](https://www.npmjs.com/package/ws) package, If you use bun, do not enable this option) */
    legacyWS?: boolean;
    /** The region of the node */
    region?: string;
}
/**
 * Some rainlink additional config option
 */
interface RainlinkAdditionalOptions {
    /** Additional custom driver for rainlink (no need 'new' keyword when add). Example: `additionalDriver: Lavalink4` */
    additionalDriver?: Constructor<AbstractDriver>[];
    /** Timeout before trying to reconnect (ms) */
    retryTimeout?: number;
    /** Number of times to try and reconnect to Lavalink before giving up */
    retryCount?: number;
    /** The retry timeout for voice manager when dealing connection to discord voice server (ms) */
    voiceConnectionTimeout?: number;
    /** The default search engine like default search from youtube, spotify,... */
    defaultSearchEngine?: string;
    /** The default volume when create a player */
    defaultVolume?: number;
    /** Search track from youtube when track resolve failed */
    searchFallback?: {
        /** Whenever enable this search fallback or not */
        enable: boolean;
        /** Choose a fallback search engine, recommended soundcloud and youtube */
        engine: string;
    };
    /** Whether to resume a connection on disconnect to Lavalink (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES) */
    resume?: boolean;
    /** When the seasion is deleted from Lavalink. Use second (Server Side) (Note: DOES NOT RESUME WHEN THE LAVALINK SERVER DIES) */
    resumeTimeout?: number;
    /** User Agent to use when making requests to Lavalink */
    userAgent?: string;
    /** Node Resolver to use if you want to customize it */
    nodeResolver?: (nodes: RainlinkNode[]) => Promise<RainlinkNode | undefined>;
    /** Custom structures for rainlink to use */
    structures?: Structures;
}
/**
 * Rainlink config interface
 */
interface RainlinkOptions {
    /** The lavalink server credentials array*/
    nodes: RainlinkNodeOptions[];
    /** The discord library for using voice manager, example: discordjs, erisjs. Check {@link Library} */
    library: AbstractLibrary;
    /** The rainlink plugins array. Check {@link RainlinkPlugin} */
    plugins?: RainlinkPlugin[];
    /** Rainlink additional options  */
    options?: RainlinkAdditionalOptions;
}
/**
 * The type enum of rainlink search function result
 */
declare enum RainlinkSearchResultType {
    TRACK = "TRACK",
    PLAYLIST = "PLAYLIST",
    SEARCH = "SEARCH"
}
/**
 * The rainlink search function result interface
 */
interface RainlinkSearchResult {
    type: RainlinkSearchResultType;
    playlistName?: string;
    tracks: RainlinkTrack[];
}
/**
 * The rainlink search function options interface
 */
interface RainlinkSearchOptions {
    /** User info of who request the song */
    requester?: unknown;
    /** Which node do user want to use (get using node name) */
    nodeName?: string;
    /** Which search engine do user want to use (get using search engine name) */
    engine?: string;
}

declare const AllowedPackets: string[];
/**
 * The abstract class for developing library
 */
declare abstract class AbstractLibrary {
    protected readonly client: any;
    protected manager: Rainlink | null;
    constructor(client: any);
    protected ready(nodes: RainlinkNodeOptions[]): void;
    /** @ignore */
    set(manager: Rainlink): AbstractLibrary;
    /**
     * A getter where the lib stores the client user (the one logged in as a bot) id
     * @returns string
     */
    abstract getId(): string;
    /**
     * For dealing ws with lavalink server
     * @returns number
     */
    abstract getShardCount(): number;
    /**
     * Where your library send packets to Discord Gateway
     * @param shardId The current shard Id
     * @param payload The payload data to request with discord gateway
     * @param important If this payload important or not
     */
    abstract sendPacket(shardId: number, payload: any, important: boolean): void;
    /**
     * Listen attaches the event listener to the library you are using
     * @param nodes All current nodes in the array
     */
    abstract listen(nodes: RainlinkNodeOptions[]): void;
    protected raw(packet: any): void;
}

declare class DiscordJS extends AbstractLibrary {
    sendPacket(shardId: number, payload: any, important: boolean): void;
    getId(): string;
    getShardCount(): number;
    listen(nodes: RainlinkNodeOptions[]): void;
}

declare class ErisJS extends AbstractLibrary {
    sendPacket(shardId: number, payload: any, important: boolean): void;
    getId(): string;
    getShardCount(): number;
    listen(nodes: RainlinkNodeOptions[]): void;
}

declare class OceanicJS extends AbstractLibrary {
    sendPacket(shardId: number, payload: any, important: boolean): void;
    getId(): string;
    getShardCount(): number;
    listen(nodes: RainlinkNodeOptions[]): void;
}

declare class Seyfert extends AbstractLibrary {
    sendPacket(shardId: number, payload: any): void;
    getId(): string;
    getShardCount(): number;
    listen(nodes: RainlinkNodeOptions[]): void;
}

/**
 * Import example:
 * @example
 * ```ts
 * new Plugin.DiscordJS(client)
 * new Plugin.ErisJS(client)
 * new Plugin.OceanicJS(client)
 * new Plugin.Seyfert(client)
 * ```
 */
declare const _default: {
    DiscordJS: typeof DiscordJS;
    ErisJS: typeof ErisJS;
    OceanicJS: typeof OceanicJS;
    Seyfert: typeof Seyfert;
};

declare enum Lavalink3loadType {
    TRACK_LOADED = "TRACK_LOADED",
    PLAYLIST_LOADED = "PLAYLIST_LOADED",
    SEARCH_RESULT = "SEARCH_RESULT",
    NO_MATCHES = "NO_MATCHES",
    LOAD_FAILED = "LOAD_FAILED"
}
declare class Lavalink3 extends AbstractDriver {
    manager: Rainlink;
    node: RainlinkNode;
    id: string;
    wsUrl: string;
    httpUrl: string;
    sessionId: string | null;
    playerFunctions: RainlinkFunctions;
    functions: RainlinkFunctions;
    protected wsClient?: RainlinkWebsocket;
    constructor(manager: Rainlink, node: RainlinkNode);
    connect(): RainlinkWebsocket;
    requester<D = any>(options: RainlinkRequesterOptions): Promise<D | undefined>;
    protected convertToV3websocket(data: UpdatePlayerInfo): false | undefined;
    protected checkUpdateExist(data: Record<string, any>): any;
    protected wsSendData(data: Record<string, unknown>): void;
    protected wsMessageEvent(data: string): void;
    updateSession(sessionId: string, mode: boolean, timeout: number): Promise<void>;
    protected debug(logs: string): void;
    wsClose(): void;
    protected testJSON(text: string): boolean;
    protected convertToV3request(data?: Record<string, any>): void;
    protected convertV4trackResponse(v3data: Record<string, any>): Record<string, any>;
    protected buildV4track(v3data: Record<string, any>): {
        encoded: any;
        info: {
            sourceName: any;
            identifier: any;
            isSeekable: any;
            author: any;
            length: any;
            isStream: any;
            position: any;
            title: any;
            uri: any;
            artworkUrl: undefined;
        };
        pluginInfo: undefined;
    };
    protected decode(base64: string): RawTrack | undefined;
}

declare class Lavalink4 extends AbstractDriver {
    manager: Rainlink;
    node: RainlinkNode;
    id: string;
    wsUrl: string;
    httpUrl: string;
    sessionId: string | null;
    playerFunctions: RainlinkFunctions;
    functions: RainlinkFunctions;
    protected wsClient?: RainlinkWebsocket;
    constructor(manager: Rainlink, node: RainlinkNode);
    connect(): RainlinkWebsocket;
    requester<D = any>(options: RainlinkRequesterOptions): Promise<D | undefined>;
    protected wsMessageEvent(data: string): void;
    protected debug(logs: string): void;
    wsClose(): void;
    updateSession(sessionId: string, mode: boolean, timeout: number): Promise<void>;
    protected decode(base64: string): RawTrack | undefined;
}

declare enum Nodelink2loadType {
    SHORTS = "shorts",
    ALBUM = "album",
    ARTIST = "artist",
    SHOW = "show",
    EPISODE = "episode",
    STATION = "station",
    PODCAST = "podcast"
}
interface NodelinkGetLyricsInterface {
    loadType: Nodelink2loadType | LavalinkLoadType;
    data: {
        name: string;
        synced: boolean;
        data: {
            startTime: number;
            endTime: number;
            text: string;
        }[];
        rtl: boolean;
    } | Record<string, never>;
}
declare class Nodelink2 extends AbstractDriver {
    manager: Rainlink;
    node: RainlinkNode;
    id: string;
    wsUrl: string;
    httpUrl: string;
    sessionId: string | null;
    playerFunctions: RainlinkFunctions;
    functions: RainlinkFunctions;
    protected wsClient?: RainlinkWebsocket;
    constructor(manager: Rainlink, node: RainlinkNode);
    connect(): RainlinkWebsocket;
    requester<D = any>(options: RainlinkRequesterOptions): Promise<D | undefined>;
    protected wsMessageEvent(data: string): void;
    protected debug(logs: string): void;
    wsClose(): void;
    protected convertV4trackResponse(nl2Data: Record<string, any>): Record<string, any>;
    updateSession(sessionId: string, mode: boolean, timeout: number): Promise<void>;
    getLyric(player: RainlinkPlayer, trackName?: string, language?: string): Promise<NodelinkGetLyricsInterface | undefined>;
    protected testJSON(text: string): boolean;
    protected decode(base64: string): RawTrack | undefined;
}

/** This class will provide some basic function of a decoder */
declare abstract class AbstractDecoder {
    /**
     * @public
     * The current position of base64 string
     */
    protected abstract position: number;
    /**
     * @public
     * The current base64 buffer
     */
    protected abstract readonly buffer: Buffer;
    /**
     * @public
     * The current base64 track */
    protected abstract readonly track: string;
    /**
     * @public
     * Get decoded track function
     */
    abstract get getTrack(): RawTrack | null;
    /**
     * @public
     * Change the current potition in base64
     */
    protected changeBytes(bytes: number): number;
    /**
     * @public
     * Read the byte on current buffer (some like boolean but only 0 and 1)
     */
    protected readByte(): number;
    /**
     * @public
     * Read the unsigned 16 bit int (same like number)
     */
    protected readUnsignedShort(): number;
    /**
     * @public
     * Read the unsigned 32 bit int (same like number)
     */
    protected readInt(): number;
    /**
     * @public
     * Read the bigint
     */
    protected readLong(): bigint;
    /**
     * @public
     * Read UTF string (same like string)
     */
    protected readUTF(): string;
}

/** A class to decode lavalink track */
declare class LavalinkDecoder extends AbstractDecoder {
    /** The current position of base64 string */
    protected position: number;
    /** The current base64 buffer */
    protected buffer: Buffer;
    /** The current base64 track */
    protected track: string;
    constructor(track: string);
    /** Get the decoded track with version detector */
    get getTrack(): RawTrack | null;
    /** Get the decoded track with version 1 */
    get trackVersionOne(): RawTrack | null;
    /** Get the decoded track with version 2 */
    get trackVersionTwo(): RawTrack | null;
    /** Get the decoded track with version 3 */
    get trackVersionThree(): RawTrack | null;
}

/** @ignore */
declare const metadata: {
    name: string;
    version: any;
    github: string;
};

declare const version: any;

export { AbstractDecoder, AbstractDriver, AbstractLibrary, type Address, AllowedPackets, type Band, type ChannelMix, type Constructor, type Distortion, type EmptyResult, type ErrorResult, type FilterOptions, type Freq, type Karaoke, Lavalink3, Lavalink3loadType, Lavalink4, LavalinkDecoder, LavalinkLoadType, type LavalinkNodeStatsResponse, type LavalinkPlayer, type LavalinkPlayerVoice, type LavalinkPlayerVoiceOptions, type LavalinkResponse, type LavalinkStats, _default as Library, type LowPass, type NodeInfo, type NodeInfoGit, type NodeInfoPlugin, type NodeInfoVersion, type NodeStats, Nodelink2, Nodelink2loadType, type NodelinkGetLyricsInterface, type PlayEncodedOptions, type PlayOptions, type Playlist, type PlaylistResult, type RWSEvents, Rainlink, type RainlinkAdditionalOptions, RainlinkConnectState, RainlinkDatabase, RainlinkEvents, type RainlinkEventsInterface, RainlinkFilter, RainlinkFilterData, type RainlinkFilterMode, RainlinkLoopMode, RainlinkNode, RainlinkNodeManager, type RainlinkNodeOptions, type RainlinkOptions, RainlinkPlayer, RainlinkPlayerEvents, RainlinkPlayerManager, RainlinkPlayerState, RainlinkPlugin, RainlinkPluginType, RainlinkQueue, type RainlinkRequesterOptions, RainlinkRest, type RainlinkSearchOptions, type RainlinkSearchResult, RainlinkSearchResultType, RainlinkTrack, RainlinkVoice, RainlinkWebsocket, type RainlinkWebsocketFHInfo, type RainlinkWebsocketOptions, RainlinkWebsocketState, type RawTrack, type ResolveOptions, type Rotation, type RoutePlanner, type SearchResult, type ServerUpdate, SourceIDs, SourceRainlinkPlugin, type StateUpdatePartial, type Structures, type Timescale, type TrackResult, type UpdatePlayerInfo, type UpdatePlayerOptions, type UpdatePlayerTrack, type VoiceChannelOptions, VoiceConnectState, VoiceState, metadata, version };
