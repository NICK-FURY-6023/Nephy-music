export type LyricScraper = (url: string, userAgent: string) => Promise<string>;
/** Options to configure {@link Lyricist} */
export interface LyricOptions {
    /** An array of async scraper functions. [learn more](https://github.com/execaman/lyricist?tab=readme-ov-file#writing-your-own-plugin) */
    plugins?: LyricScraper[];
    /** Whether to save last successful fetch result */
    saveLastResult?: boolean;
}
/** An object of the platform that streams this song */
export interface LyricStream {
    /** Name of the platform that streams this song */
    source: string;
    /** Direct URL to the song on this platform */
    stream: string;
}
/** Additional info on the song based on SERP */
export interface LyricInfo {
    /** Label of a info field */
    label: string;
    /** Value of that info field */
    value: string;
}
/** Source of the lyrics provider */
export interface LyricSource {
    /** Name of the source of this lyric */
    name: string;
    /** A URL to the source of this lyric */
    url: string;
}
/** A successful fetch result */
export interface LyricResult {
    song?: {
        title: string;
        subtitle: string;
    };
    info?: LyricInfo[];
    listen?: LyricStream[];
    lyrics: string;
    source: LyricSource;
}
export declare class Lyricist {
    #private;
    /** A map of all available plugins */
    plugins: Map<string, LyricScraper>;
    /** Last successful fetch result if {@link LyricOptions.saveLastResult} was enabled */
    lastResult?: LyricResult;
    constructor(options?: LyricOptions);
    /**
     * Fetch a lyric by query; minimum recommended delay: 3s
     * @param query Name of the song or full query
     * @param attempt Number of attempts to make if Google doesn't have the lyric
     * @returns {Promise<LyricResult>}
     */
    fetch(query: string, attempt?: number): Promise<LyricResult>;
}
